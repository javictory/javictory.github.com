<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javicroty&#39;s Blog</title>
    <description>It&#39;s my own blog Recording my growth.&lt;br&gt; &quot;Stay hungry. Stay foolish.--Steve Jobs&quot;
</description>
    <link>http://javictory.info/</link>
    <atom:link href="http://javictory.info/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 20 Mar 2016 16:29:09 +0800</pubDate>
    <lastBuildDate>Sun, 20 Mar 2016 16:29:09 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>Socket编程的select模型</title>
        <description>&lt;p&gt;在掌握了socket相关的一些函数后，套接字编程还是比较简单的，日常工作中碰到很多的问题就是客户端/服务器模型中，如何让服务端在同一时间高效的处理多个客户端的连接，我们的处理办法可能会是在服务端不停的监听客户端的请求，有新的请求到达时，开辟一个新的线程去和该客户端进行后续处理，但是这样针对每一个客户端都需要去开辟一个新的线程，效率必定底下。&lt;/p&gt;

&lt;p&gt;其实，socket编程提供了很多的模型来处理这种情形，我们只要按照模型去实现我们的代码就可以解决这个问题。主要有select模型和重叠I/o模型，以及完成端口模型。这次，我们主要介绍下select模型，该模型又分为普通select模型，wsaasyncselect模型，wsaeventselect模型。我们将通过样例代码的方式逐一介绍。&lt;/p&gt;

&lt;h1 id=&quot;select&quot;&gt;一、select模型&lt;/h1&gt;

&lt;p&gt;使用该模型时，在服务端我们可以开辟两个线程，一个线程用来监听客户端的连接请求，另一个用来处理客户端的请求。&lt;/p&gt;

&lt;p&gt;主要用到的函数为select函数。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;全局变量：

fd_set  g_fdClientSock;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程1处理函数：
	SOCKET listenSock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sockaddr_in sin;
sin.sin_family = AF_INET;
sin.sin_port = htons(7788);
sin.sin_addr.S_un.S_addr = INADDR_ANY;

int nRet = bind( listenSock, (sockaddr*)&amp;amp;sin, (int)(sizeof(sin)));
if ( nRet == SOCKET_ERROR )
{
    DWORD errCode = GetLastError();
    return;
}

listen( listenSock, 5);

int clientNum = 0;

sockaddr_in clientAddr;

int nameLen = sizeof( clientAddr );

while( clientNum &amp;lt; FD_SETSIZE )
{
    SOCKET clientSock = accept( listenSock, (sockaddr*)&amp;amp;clientAddr, &amp;amp;nameLen );
    FD_SET( clientSock, &amp;amp;g_fdClientSock);
    clientNum++;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程2处理函数：
	fd_set fdRead;
    FD_ZERO( &amp;amp;fdRead );
    int nRet = 0;
    char* recvBuffer =(char*)malloc( sizeof(char) * 1024 );&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( recvBuffer == NULL )
{
    return;
}

memset( recvBuffer, 0, sizeof(char) * 1024 );
while ( true )
{
    fdRead = g_fdClientSock;
    nRet = select( 0, &amp;amp;fdRead, NULL, NULL, NULL );
    if ( nRet != SOCKET_ERROR )
    {
        for ( int i = 0; i &amp;lt; g_fdClientSock.fd_count; i++ )
        {
            if ( FD_ISSET(g_fdClientSock.fd_array[i],&amp;amp;fdRead)  )
            {
                memset( recvBuffer, 0, sizeof(char) * 1024 );
                nRet = recv( g_fdClientSock.fd_array[i], recvBuffer, 1024, 0);
                if ( nRet == SOCKET_ERROR )
                {
                    closesocket( g_fdClientSock.fd_array[i] )；
                        FD_CLR( g_fdClientSock.fd_array[i], &amp;amp;g_fdClientSock );
                }
                else
                {
                    //todo:后续处理
                   }
            }
        }
    }
}

if ( recvBuffer != NULL )
{
    free( recvBuffer );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该模型有个最大的缺点就是，它需要一个死循环不停的去遍历所有的客户端套接字集合，询问是否有数据到来，这样，如果连接的客户端很多，势必会影响处理客户端请求的效率，但它的优点就是解决了每一个客户端都去开辟新的线程与其通信的问题。如果有一个模型，可以不用去轮询客户端套接字集合，而是等待系统通知，当有客户端数据到来时，系统自动的通知我们的程序，这就解决了select模型带来的问题了。&lt;/p&gt;

&lt;p&gt;二、WsaAsyncSelect模型
WsaAsyncSelect模型就是这样一个解决了普通select模型问题的socket编程模型。它是在有客户端数据到来时，系统发送消息给我们的程序，我们的程序只要定义好消息的处理方法就可以了，用到的函数只要是WSAAsyncSelect,如：&lt;/p&gt;

&lt;p&gt;首先，我们定义一个Windows消息，告诉系统，当有客户端数据到来时，发送该消息给我们。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define  UM_SOCK_ASYNCRECVMSG  WM_USER + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的处理函数中可以如下监听客户端的连接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKET listenSock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
sockaddr_in sin;
sin.sin_family = AF_INET;
sin.sin_port = htons(7788);
sin.sin_addr.S_un.S_addr = INADDR_ANY;
int nRet = bind( listenSock, (sockaddr*)&amp;amp;sin, (int)(sizeof(sin)));
if ( nRet == SOCKET_ERROR )
{
    DWORD errCode = GetLastError();
    return;
}

listen( listenSock, 5);

int clientNum = 0;
sockaddr_in clientAddr;
int nameLen = sizeof( clientAddr );

while( clientNum &amp;lt; FD_SETSIZE )
{
    SOCKET clientSock = accept( listenSock, (sockaddr*)&amp;amp;clientAddr, &amp;amp;nameLen );
    //hWnd为接收系统发送的消息的窗口句柄
     WSAAsyncSelect( clientSock, hWnd, UM_SOCK_ASYNCRECVMSG, FD_READ | FD_CLOSE );
    clientNum++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们需要在我们的窗口添加对UM_SOCK_ASYNCRECVMSG消息的处理函数，在该函数中真正接收客户端发送过来的数据，在这个消息处理函数中的wparam参数表示的是客户端套接字，lparam参数表示的是发生的网络事件如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKET clientSock = (SOCKET)wParam;
if ( WSAGETSELECTERROR( lParam ) )
{
  closesocket( clientSock );
  return;
}

switch ( WSAGETSELECTEVENT( lParam ) )
{
   case FD_READ:
   {
       char recvBuffer[1024] = {&#39;\0&#39;};
       int nRet = recv( clientSock, recvBuffer, 1024, 0 );
       if ( nRet &amp;gt; 0 )
       {
            szRecvMsg.AppendFormat(_T(&quot;Client %d Say:%s\r\n&quot;), clientSock, recvBuffer );
       }
       else
       {
            //client disconnect
            szRecvMsg.AppendFormat(_T(&quot;Client %d Disconnect!\r\n&quot;), clientSock );
       }
    }                              

    break;

  case FD_CLOSE:
  {
       closesocket( clientSock );
       szRecvMsg.AppendFormat(_T(&quot;Client %d Disconnect!\r\n&quot;), clientSock );
  }

  break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到WsaAsyncSelect模型是非常简单的模型，它解决了普通select模型的问题，但是它最大的缺点就是它只能用在windows程序上，因为它需要一个接收系统消息的窗口句柄，那么有没有一个模型既可以解决select模型的问题，又不限定只能是windows程序才能用呢？下面我们来看看WsaEventSelect模型。&lt;/p&gt;

&lt;p&gt;三、WsaEventSelect模型&lt;/p&gt;

&lt;p&gt;WsaEventSelect模型是一个不用主动去轮询所有客户端套接字是否有数据到来的模型，它也是在客户端有数据到来时，系统发送通知给我们的程序，但是，它不是发送消息，而是通过事件的方式来通知我们的程序，这就解决了WsaAsyncSelect模型只能用在windows程序的问题。&lt;/p&gt;

&lt;p&gt;该模型的实现，我们也可以开辟两个线程来进行处理，一个用来接收客户端的连接请求，一个用来与客户端进行通信，用到的主要函数有WSAEventSelect，WSAWaitForMultipleEvents，WSAEnumNetworkEvents实现方式如下：&lt;/p&gt;

&lt;p&gt;首先定义三个全局数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKET      g_SockArray[MAX_NUM_SOCKET];//存放客户端套接字

WSAEVENT    g_EventArray[MAX_NUM_SOCKET];//存放该客户端有数据到来时，触发的事件

UINT32      g_totalEvent = 0;//记录客户端的连接数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程1处理函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKET listenSock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
sockaddr_in sin;
sin.sin_family = AF_INET;
sin.sin_port = htons(7788);
sin.sin_addr.S_un.S_addr = INADDR_ANY;
int nRet = bind( listenSock, (sockaddr*)&amp;amp;sin, (int)(sizeof(sin)));
if ( nRet == SOCKET_ERROR )
{
    DWORD errCode = GetLastError();
    return；
}

listen( listenSock, 5);

sockaddr_in clientAddr;
int nameLen = sizeof( clientAddr );
while( g_totalEvent &amp;lt; MAX_NUM_SOCKET )
{
    SOCKET clientSock = accept( listenSock, (sockaddr*)&amp;amp;clientAddr, &amp;amp;nameLen );
    if ( clientSock == INVALID_SOCKET )
    {
        continue;
    }
    g_SockArray[g_totalEvent] = clientSock;

    if( (g_EventArray[g_totalEvent] = WSACreateEvent()) == WSA_INVALID_EVENT )
    {
        continue;
    }

    WSAEventSelect( clientSock, g_EventArray[g_totalEvent],FD_READ | FD_CLOSE );
    g_totalEvent++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程2的处理函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int nIndex = 0;
char* recvBuffer =(char*)malloc( sizeof(char) * 1024 );

if ( recvBuffer == NULL )
{
	return；
}

memset( recvBuffer, 0, sizeof(char) * 1024 );

while( true )
{
    nIndex = WSAWaitForMultipleEvents( g_totalEvent, g_EventArray, FALSE, WSA_INFINITE,FALSE );
    if ( nIndex == WSA_WAIT_FAILED )
    {
        continue;
    }
    else
    { 
        WSAResetEvent( g_EventArray[ nIndex - WSA_WAIT_EVENT_0]);
        SOCKET clientSock = g_SockArray[ nIndex - WSA_WAIT_EVENT_0 ];
        WSANETWORKEVENTS wsaNetWorkEvent;

        int nRet = WSAEnumNetworkEvents( clientSock, g_EventArray[nIndex - WSA_WAIT_EVENT_0], &amp;amp;wsaNetWorkEvent );
        if ( SOCKET_ERROR == nRet )
        {
            continue;
        }
        else if ( wsaNetWorkEvent.lNetworkEvents &amp;amp; FD_READ )
        {
            if ( wsaNetWorkEvent.iErrorCode[FD_READ_BIT] != 0 )
            {
                //occur error
                closesocket( clientSock );
            }
            else 
            {
                memset( recvBuffer, 0, sizeof(char) * 1024 );
                nRet = recv( clientSock, recvBuffer, 1024, 0);
                if ( nRet == SOCKET_ERROR )
                {
                    closesocket( clientSock );
                }
                else
                {
                    //todo:对接收到的客户端数据进行处理
                    }
             }
         }
         else if( wsaNetWorkEvent.lNetworkEvents &amp;amp; FD_CLOSE )
         {
            if ( wsaNetWorkEvent.iErrorCode[FD_CLOSE_BIT] != 0 )
            {
                //occur error
                closesocket( clientSock );
            }
            else
            {
                closesocket( clientSock );
            }  
         }
    }
}

if ( recvBuffer != NULL )
{
    free( recvBuffer );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该模型通过一个死循环里面调用WSAWaitForMultipleEvents函数来等待客户端套接字对应的Event的到来，一旦事件通知到达，就通过该套接字去接收数据。虽然WsaEventSelect模型的实现较前两种方法复杂，但它在效率和兼容性方面是最好的。&lt;/p&gt;

&lt;p&gt;以上三种模型虽然在效率方面有了不少的提升，但它们都存在一个问题，就是都预设了只能接收64个客户端连接，虽然我们在实现时可以不受这个限制，但是那样，它们所带来的效率提升又将打折扣。&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Jan 2016 19:30:45 +0800</pubDate>
        <link>http://javictory.info/sockets/2016/01/13/windows-socket-select-module.html</link>
        <guid isPermaLink="true">http://javictory.info/sockets/2016/01/13/windows-socket-select-module.html</guid>
        
        
        <category>sockets</category>
        
      </item>
    
      <item>
        <title>Ubuntu完全教程，让你成为Ubuntu高手！</title>
        <description>&lt;h1 id=&quot;ubuntu&quot;&gt;Ubuntu的发音&lt;/h1&gt;

&lt;p&gt;Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）&lt;/p&gt;

&lt;p&gt;大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u’buntu ，oo-boon-too 。&lt;/p&gt;

&lt;p&gt;如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。&lt;/p&gt;

&lt;p&gt;Ubuntu的中文发音大约为： 乌班图&lt;/p&gt;

&lt;h1 id=&quot;ubuntu-1&quot;&gt;Ubuntu的涵义&lt;/h1&gt;

&lt;p&gt;Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。&lt;/p&gt;

&lt;h1 id=&quot;ubuntu-2&quot;&gt;Ubuntu当前版本&lt;/h1&gt;

&lt;p&gt;Ubuntu Linux v6.06 LTS (Dapper Drake)&lt;/p&gt;

&lt;p&gt;LTS：Long Term Support&lt;/p&gt;

&lt;p&gt;Dapper Drake：当前版本的开发代号&lt;/p&gt;

&lt;h1 id=&quot;ubuntu-3&quot;&gt;Ubuntu的特点&lt;/h1&gt;

&lt;p&gt;Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。&lt;/p&gt;

&lt;p&gt;Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。&lt;/p&gt;

&lt;p&gt;自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。&lt;/p&gt;

&lt;p&gt;Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。&lt;/p&gt;

&lt;p&gt;Ubuntu 包涵了超过 16,000 种软件， 核心的桌面系统却只有一张光盘， Ubuntu 覆盖了所有的桌面应用程序,&lt;/p&gt;

&lt;p&gt;从文字处理，电子表格到 web 服务器和开发设计环境一应俱全。 详情查看 Ubuntu 桌面 和 Ubuntu 服务器的介绍。&lt;/p&gt;

&lt;p&gt;Ubuntu相对其它Linux发行版的主要特点&lt;/p&gt;

&lt;p&gt;基于Debian/Linux，使用 APT 包管理系统。&lt;/p&gt;

&lt;p&gt;相对于Fedora Code： APT 包管理系统优雅地解决了依赖问题，并且可以从容的在线安装升级&lt;/p&gt;

&lt;p&gt;相对于Debian：软件更新积极，而Debian较保守。&lt;/p&gt;

&lt;p&gt;相对于Gentoo：基本无需编译，省力、省时、省心。&lt;/p&gt;

&lt;p&gt;基本操作
进入系统&lt;/p&gt;

&lt;p&gt;在登录界面中输入您的用户名，然后系统将提问您的密码&lt;/p&gt;

&lt;p&gt;输入您的密码后，回车，稍事等待，您便可以进入Ubuntu系统&lt;/p&gt;

&lt;p&gt;点击桌面左上角的图标，您可以打开一个菜单（或者使用 Alt+F1 组合键）&lt;/p&gt;

&lt;p&gt;如果您想退出系统，可以点击该图标&lt;/p&gt;

&lt;p&gt;在桌面上方启动栏中，包含了一些常用程序的启动图标这些图标也可以在开始菜单中找到&lt;/p&gt;

&lt;p&gt;现在点击FireFox图标，您便可以使用FireFox浏览器冲浪&lt;/p&gt;

&lt;p&gt;或者按下 Alt+F2 组合键，弹出一个运行命令对话框。输入 firefox 后回车，同样可以启动FireFox&lt;/p&gt;

&lt;p&gt;在菜单中找到 终端&lt;/p&gt;

&lt;p&gt;点击它便开启了一个终端窗口，您可以在终端窗口中运行命令&lt;/p&gt;

&lt;p&gt;也可以在控制台中输入命令。使用 Ctrl+Alt+[F1~F6] ，您可以切换到1~6号控制台&lt;/p&gt;

&lt;p&gt;使用 Ctrl+Alt+F7 可以返回图形界面（您可以使用 Ctrl+Alt+BackSpace 将图形界面关闭）&lt;/p&gt;

&lt;p&gt;命令行提示符&lt;/p&gt;

&lt;p&gt;user@ubuntu:~$ 为命令提示符， @ 之前的部分为当前用户ID， @ 与 : 之间的部分，为您的主机名称， : 与 $ 之间的部分，为当前的路径。&lt;/p&gt;

&lt;p&gt;退出系统&lt;/p&gt;

&lt;p&gt;您可以点击这一个图标来退出系统&lt;/p&gt;

&lt;p&gt;也可以在终端或者控制台中输入命令&lt;/p&gt;

&lt;p&gt;sudo halt&lt;/p&gt;

&lt;p&gt;系统会提问您密码，输入正确密码，便可以退出系统&lt;/p&gt;

&lt;p&gt;在以后的章节中，如果我们提示您输入命令，那么您即可以在终端中输入，也可以在控制台中输入。如果只是启动应用程序，还可以使用 Alt+F2 组合键。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;安装&lt;/h1&gt;
&lt;p&gt;## 分区概念 ##&lt;/p&gt;

&lt;p&gt;首先我们需要知道，硬盘分区的存在，是由硬盘的物理特性决定的，并不会因为不同的操作系统而有所改变。(源码网教程下载，www.codepub.com)&lt;/p&gt;

&lt;p&gt;请您把一块硬盘想象为一本书……即便您不喜欢读书，您也一定非常熟悉它，所有的书都是相同的，包括我们使用的课本……您肯定非常熟悉&lt;/p&gt;

&lt;p&gt;一本完整的书，通常包括书名、索引和正文。&lt;/p&gt;

&lt;p&gt;如果您需要Linux，您首先需要找到一本书名为《linux》的书，书名相当于硬盘中的MBR，也就是主引导纪录。不同的是，MBR可以是几个书名合在一起，类似于《XX合订本》。这部分内容暂时还没有什么实用价值，您只需要大概的了解。&lt;/p&gt;

&lt;p&gt;而正文，就是硬盘中纪录的数据，这也非常容易理解，且对于安装系统并没有什么影响，所以现在我们来了解索引&lt;/p&gt;

&lt;p&gt;索引相当于硬盘中的分区表，书中的每一个章节，相当于硬盘中的一个分区，它起始和结束的页次，都可以在索引中找到。试想，如果阅读一本撕掉索引的书，您将很难找到您想阅读的部分。同样，如果没有分区表，操作系统也不能够在硬盘上定位数据的位置。&lt;/p&gt;

&lt;p&gt;由于历史的原因，硬盘中的分区表大小受到了限制，最多只可以容纳四个分区（主分区）。如果一本书，它的索引最多只能有四个章节，那不是太可怕了么？很多书的内容远远不止四个章节啊！&lt;/p&gt;

&lt;p&gt;于是聪明的人们想到了一个变通的办法，就是利用其中的一个章节，来存储其它部分的索引。比如第一章是前言，第二章是其它部分的索引，我们翻到第二&lt;/p&gt;

&lt;p&gt;章，呵呵，这里是第二个索引，因为只有第一个索引受四个章节的限制，所以这个索引的内容可以非常的详尽。第二个索引就是分区表中的扩展分区了，其中定义的&lt;/p&gt;

&lt;p&gt;章节，就是硬盘中的逻辑分区，不是很难理解吧？&lt;/p&gt;

&lt;p&gt;明白了这一点，我们来看看Linux和Windows对于分区不同的表示方法：&lt;/p&gt;

&lt;p&gt;可能您已经很熟悉Windows了，它使用盘符来表示分区，比如 C: D: E:&lt;/p&gt;

&lt;p&gt;，每一个分区使用一个盘符来标识，而且顺序可以颠倒， D:&lt;/p&gt;

&lt;p&gt;并不一定就是您系统中的第二个分区。（如果您给第二个分区分配最后一个硬盘盘符，把所有的盘符按顺序排列好，并且重装一次系统，您就会理解什么叫作“头&lt;/p&gt;

&lt;p&gt;疼”了：）&lt;/p&gt;

&lt;p&gt;而在Linux中，分区是这样表示的&lt;/p&gt;

&lt;p&gt;/dev/hda               /dev/hda1          /dev/hda2             /dev/hda5/            dev/sdb1&lt;/p&gt;

&lt;p&gt;以 /dev/hda5 为例:&lt;/p&gt;

&lt;p&gt;因为在Linux中，每一个设备都是用 /dev/ 文件夹下的一个文件来表示，所以 /dev/hda5 中， /dev/ 表示的是根目录下的dev目录，我们来看剩下的部分 hda5 。&lt;/p&gt;

&lt;p&gt;前两位的字母 hd 表示这是一块IDE硬盘，如果是 sd ，则代表SATA硬盘，或者闪存等外设。&lt;/p&gt;

&lt;p&gt;第三位的字母 a 表示这是该类型接口上的第一个设备。同理， b、c、d…… 分别代表该类型接口上的第二三四……个设备。例如 hdc 表示第二个IDE接口上的主硬盘（每个IDE接口上允许一个主设备和一个从设备）。&lt;/p&gt;

&lt;p&gt;第四位的数字 5，并不表示这是该硬盘中的第5个分区，而是第一个逻辑分区。因为在Linux中，为了避免不必要的混乱，分区的顺序是不能改变的，分区标识则由它们在硬盘中的位置决定。系统又要为所有可能的主分区预留标识，所以 1-4 一定不会是逻辑分区， 5 则是第一个逻辑分区，以此类推。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装中的注意事项&lt;/h2&gt;

&lt;p&gt;在Ubuntu系统的安装过程中，您需要选择系统目录的挂载点。&lt;/p&gt;

&lt;p&gt;我们知道，安装Windows时，我们可以选择把系统安装在哪一个分区，把系统挂载到分区上。而在buntu/Linux中则相反，我们要把分区挂载到系统中。当我们使用Windows的安装方式，把系统挂载到分区上，我们就不可能把Windows目录放在C盘，而把MyDocuments目录放到其它分区。您或者出于习惯，或者出于数据安全方面的考虑，通常把文档放到其它分区中。但是Windows下很多软件保存文件的默认目录就是MyDocument目录，这就比较不方便。&lt;/p&gt;

&lt;p&gt;在系统安装完成后，我们还是可以将MyDocuments目录转移到其它分区中，不过有点麻烦，可能许多朋友还不知道怎么去作……而任何一种Linux系统时，当然包括Ubuntu，我们可以在系统安装时就把分区挂载到目录下， /home 目录相当于Windows的MyDocuments ，我们可以把 /dev/hda5 挂载到此目录下，这样我们往 /home目录里存东西的时候，其实保存在第一个扩展分区中。如果再一次安装系统，只要把这个分区挂载到 /home目录下，那么进入新系统就像回家一样，真是太棒了。&lt;/p&gt;

&lt;p&gt;理论上来讲，您可以将分区挂载到任何目录下面，您可以自定义挂载的路径。但是我们并不推荐您这么作，因为那没有任何意义。系统安装程序向您建议的挂载目录，通常也是我们向您建议的，现在我们来了解一下，这些目录通常都是用来作什么的：&lt;/p&gt;

&lt;p&gt;/        根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它！（在绝大多数情况下，有2G的容量应该是够用了。当然了，很多东西都是多多益善的：）&lt;/p&gt;

&lt;p&gt;Swap         交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量只要大于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。&lt;/p&gt;

&lt;p&gt;/home        前面已经介绍过了，这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区&lt;/p&gt;

&lt;p&gt;/usr   应用程序目录。大部分的软件都安装在这里。如果您计划安装许多软件，建议您也给它分配一个分区&lt;/p&gt;

&lt;p&gt;/var            如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区&lt;/p&gt;

&lt;p&gt;/boot          如果您的硬盘不支持LBA模式（我想那不太可能:），您最好挂载它，如果挂载硬盘的第一个分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了&lt;/p&gt;

&lt;p&gt;在文件系统这一环节中，我们建议您选择： ReiserFS&lt;/p&gt;

&lt;p&gt;也许您注意到了，Windows中，盘符既用于表示硬件（硬盘上的分区）,又用于表示系统中的路径。而Linux中，硬件就是硬件，路径就是路径，不会混淆在一起，简单直接！&lt;/p&gt;

&lt;h1 id=&quot;linux&quot;&gt;Linux基础&lt;/h1&gt;
&lt;p&gt;## Shell ##&lt;/p&gt;

&lt;p&gt;可能您早已能够熟练的使用GUI（图形用户界面），例如您可以使用鼠标双击一个图标，来打开或者执行它。&lt;/p&gt;

&lt;p&gt;我们来看这个过程: 您使用鼠标定位桌面上的一个程序图标，按下左键两次。系统读取鼠标指针的位置，并且判断该位置下图标的涵义，根据预设的双击动作，运行程序或者打开文件。&lt;/p&gt;

&lt;p&gt;这一套GUI系统，便是一种Shell，它的作用是实现人机交互。如果我们不能够控制电脑，那么电脑还不如电视机好玩，不是么？电视机也可以选择频道（电视机的遥控器，也是一种人机交互的界面，不过相对于电脑，确实是相当简单了：）&lt;/p&gt;

&lt;p&gt;易于上手、界面直观是GUI的优点，但是GUI为不意味着简单！或许您有类似经历: 桌面上有几十个程序的启动图标，也知道它们的名字，但是翻出一个来，并不是一件轻松的事情。&lt;/p&gt;

&lt;p&gt;我的Windows系统中，桌面上摆满了各种图标，每当启动一个程序的时候，我都很是困扰。后来尝试了 音速启动 这类的程序启动管理器，效果还是差强人意。&lt;/p&gt;

&lt;p&gt;在我的不懈努力下，这个难道最终得到了解决： 将快捷方式名称简化，放到特定目录下，使用 Win+R 组合键呼出 运行对话框，键入快捷方式的名称来运行该程序。比如 反恐精英 的快捷方式为 cs ，我把它放在 Windows 目录下; 运行 cs命令，就可以去维护世界和平了。&lt;/p&gt;

&lt;p&gt;这么多快捷方式，统统放到 Windows 目录下，非常混乱。因此，我在D盘建立了一个名为 path的目录，并把它的路径加入到环境变量的 path 项中，快捷方式放在 D:\path目录中。即便重装系统，只要在环境变量中重新加入此路径，原来的程序大多可以直接以命令来运行……我的许多朋友强烈要示我帮他们设定这种启动方式，因为这确实很方便：）&lt;/p&gt;

&lt;p&gt;其实在Linux下，所有的程序都可以通过命令运行。虽然Linux也有GUI，但是它并不比Windows的GUI更优秀！上面只是简单的介绍了CLI（命令行界面）相对GUI的优越之处，使用CLI还有更多的好处，您会慢慢体会到的。&lt;/p&gt;

&lt;p&gt;当然了，在您的印象中，CLI一定非常的不友善，缺少亲和力，冷漠而拒人于千里之外……您和CLI之间甚至有代沟的存在：）&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;命令&lt;/h2&gt;

&lt;p&gt;坦白的说，冷不丁见到那么老长的一串命令，谁都会毛骨悚然。&lt;/p&gt;

&lt;p&gt;也许您使用过DOS，留下这种印象：命令先放一边，光是正确的输入目录、文件名都够瞧的。而且DOS不区分大小写，要是像Linux一样区分大小写，那多恐怖啊！！！&lt;/p&gt;

&lt;p&gt;其实Linux命令行具有补全功能，非常实用。假设有这样一个命令：&lt;/p&gt;

&lt;p&gt;command path/file&lt;/p&gt;

&lt;p&gt;如果只有一个以 c 起始的命令，键入 c ，再按一次 tab 键，系统将自动补全该命令余下的部分。 只要 c tab 两次按键，就可以完成 command 的输入。&lt;/p&gt;

&lt;p&gt;如果不只一个 c 起始的命令，那么您可以按两次 tab 键，系统会列出所有符合条件的选项，也就是以 c 起始的所有命令。进一步输入 o ，如果只有一个以 co 起始的命令（一直输入，直到项符合条件的选项唯一），再按一次 tab ，命令就被补全完整。&lt;/p&gt;

&lt;p&gt;路径和文件名也可以通过 tab 键来补全。还有一种 遍历补全 的方式，如果您的文件名是中文，而您不想切换输入法；甚至您的文件名中出现乱码，无法输入，这时 遍历补全 就可以大显身手了。这部分内容我们稍后再谈：）&lt;/p&gt;

&lt;p&gt;现在我们来了解命令的语法结构，这一部分相当重要，您可得看仔细。&lt;/p&gt;

&lt;p&gt;我们知道，任何语言都有特定的语法结构，以我们的中文为例：&lt;/p&gt;

&lt;p&gt;我们郑重地推荐您Ubuntu/Linux！&lt;/p&gt;

&lt;p&gt;这个句子的语法尽管简单，却是大部分的命令行采用的句型。让我们看一下，这个句子里都有些什么：&lt;/p&gt;

&lt;p&gt;我们&lt;/p&gt;

&lt;p&gt;主语，Linux命令的执行者只有一个，所以主语一概省略。&lt;/p&gt;

&lt;p&gt;推荐&lt;/p&gt;

&lt;p&gt;一个动词，作为谓语而存在。Linux命令中，这一部分是必须的。这一部分也是不同命令之间最根本的区别方式，所以它通常作为命令名，写在最前面。键入 date 命令，您可以查看当前的时间日期。（ 应用程序-&amp;gt;附件-&amp;gt;终端 ）&lt;/p&gt;

&lt;p&gt;郑重的&lt;/p&gt;

&lt;p&gt;状语，用来修饰谓语。与之相对应，Linux命令可以使用参数来精细调节程序的行为。为了与命令的操作对象相区别，参数前通常要加 - 或者 – 符号。原则上，在命令名之后，参数的位置可以随意，但是为了养成一个良好的习惯，我们建议您在命令名后直接跟参数。&lt;/p&gt;

&lt;p&gt;您 Ubuntu/linux&lt;/p&gt;

&lt;p&gt;这两个部分都是宾语，它们是命令的操作对象。大部分的命令只有一个操作对象，也有一些命令是双宾语结构的，具有一个直接宾语和一个间接宾语。比如 拷贝 这个命令 cp (copy)&lt;/p&gt;

&lt;p&gt;分隔符&lt;/p&gt;

&lt;p&gt;我们的汉语是象形文字，没有分隔符。但是所有的拼音文字中都有分隔符，来分隔单词。Linux命令中同样使用空格作分隔符。&lt;/p&gt;

&lt;p&gt;cp a /home 表示把当前目录下的 a 文件，拷贝到 /home 目录下。（命令的不同部分使用空格分隔，连续的空格视为一个空格）&lt;/p&gt;

&lt;p&gt;上面的那句话，翻译成Linux的命令，应该是这个样子的：&lt;/p&gt;

&lt;p&gt;推荐 –郑重的 您 Ubuntu/Linux （按照传统，“-”后跟简写为单个字母的参数，“–”后跟完整单词的参数。不过也有例外：）&lt;/p&gt;

&lt;p&gt;哈，Linux的命令也蛮简单吧？&lt;/p&gt;

&lt;h2 id=&quot;linux-1&quot;&gt;Linux程序、进程&lt;/h2&gt;

&lt;p&gt;或许您会这样想，Linux命令的句型确实不难，但是那么多命令，我怎么知道它们都是作什么的呢？而且不同的系统中，可以使用的命令似乎也不太一样，这真让人困惑……&lt;/p&gt;

&lt;p&gt;其实Linux的命令，运行的是Linux系统中的程序。只要您已安装了程序，您就可以通过命令来运行它，并且可以使用参数来精细的调整它的运行状态。也可以通过点击启动图标来运行，不过启动图标不能够方便的调整参数，并不是很方便。&lt;/p&gt;

&lt;p&gt;举一个例子：&lt;/p&gt;

&lt;p&gt;mplayer -shuffle -loop 3 -playlist mymp3.list&lt;/p&gt;

&lt;p&gt;可能您运行上面命令，系统会提示您 无法找到命令，那是因为您没有安装mplayer这个程序。mplayer是我见过的支持格式最多的播放器，几乎任何已知格式的多媒体文件，都可以使用mplayer来播放。它包含一个图形界面的前端，您可以在菜单中找到它，鼠标点击运行;也可以通过执行命令来运行它的命令行版本。&lt;/p&gt;

&lt;p&gt;如果您的系统中没有mplayer播放器，我们建议您安装一个。关于程序的安装，请参阅 软件安装 。&lt;/p&gt;

&lt;p&gt;上面命令中， mplayer 调用了mplayer播放器程序。参数 -shuffle 表示随机播放， -loop 表示循环播放，后面的3 为循环的次数，如果为 0 ,则一直播放。 -playlist 表示播放列表中的曲目。我们可以把mp3的路径放到 mymp3.list文件中，让mplayer来播放它们。&lt;/p&gt;

&lt;p&gt;进程 为运行中的程序，是程序在内存中的镜像。&lt;/p&gt;

&lt;p&gt;好了，现在您已经了解了 Shell 、 命令 、 程序 、 进程 的概念，您基本上也就了解了Linux（Linux系统真是非常简洁，而且容易理解：）。&lt;/p&gt;

&lt;p&gt;但只知道这些，您并不能顺畅使用。接下来的章节中，我们来进一步介绍它的细节。&lt;/p&gt;

&lt;h1 id=&quot;linux-2&quot;&gt;Linux系统简介&lt;/h1&gt;
&lt;p&gt;## 路径 ##&lt;/p&gt;

&lt;p&gt;路径分为绝对路径和相对路径。&lt;/p&gt;

&lt;p&gt;绝对路径的起始点为根目录 / ，例如 /usr/local/bin 就是绝对路径，它指向系统中一个绝对的位置，不受其它因素影响。&lt;/p&gt;

&lt;p&gt;相对路径的起始点为当前目录，如果您现在位于 /usr 目录，那么相对路径 local/bin 所指示的位置为 /usr/local/bin&lt;/p&gt;

&lt;p&gt;也就是说，相对路径所指示的位置，除了相对路径本身，还受到当前位置的影响。例如Linux系统中常见的目录 /bin 、 /usr/bin、 /usr/local/bin ，如果只有一个相对路径 bin，那么它指示的位置可能上面三个目录中的任意一个，也可能是其它目录。&lt;/p&gt;

&lt;p&gt;如果我告诉您到 bin 目录寻找一个文件，您可能搞不清楚是哪一个 bin 目录。只有当前位置确定，相对路径指示的位置才能够确定。&lt;/p&gt;

&lt;p&gt;现在我说， /usr/local 目录下，它的相对路径 bin 中有某个文件，这样就比较明确了。&lt;/p&gt;

&lt;p&gt;在相对路径中 . 表示当前目录， .. 表示当前目录的上一级目录。&lt;/p&gt;

&lt;p&gt;假设您安装了一个程序，它的主程序没有被放置到上面三个 bin 目录中的任何一个，或者其它系统能够找到的地方，您就得告诉系统，它的可执行文件在哪里。&lt;/p&gt;

&lt;p&gt;可以使用绝对路径，例如： /home/user/bin/可执行文件&lt;/p&gt;

&lt;p&gt;或者定位到 /home/user/bin 目录，使用相对目录来定位它 ./可执行文件&lt;/p&gt;

&lt;p&gt;如果您定位到了它的子目录，比如 /home/user/bin/gui，您可以使用 .. 来表示它的上级目录 ../可执行文件&lt;/p&gt;

&lt;p&gt;路径相关命令&lt;/p&gt;

&lt;p&gt;cd (change directory) 更改目录。&lt;/p&gt;

&lt;p&gt;pwd (print working directory)显示当前路径。&lt;/p&gt;

&lt;p&gt;ls (list) 显示当前目录中的文件列表。&lt;/p&gt;

&lt;p&gt;请尝试以下操作：&lt;/p&gt;

&lt;p&gt;cd /etc 进入“/etc”目录，这里使用的是绝对路径&lt;/p&gt;

&lt;p&gt;pwd 显示当前路径，这个命令返回结果“/etc”&lt;/p&gt;

&lt;p&gt;cd init.d 进入“/etc”目录的子目录“init.d”，这里使用的是相对路径&lt;/p&gt;

&lt;p&gt;cd .. 进入上一级目录“/etc”&lt;/p&gt;

&lt;p&gt;cd ../home “/etc” 目录的上一级目录为“/”，它的子目录“home”为“/home”&lt;/p&gt;

&lt;p&gt;cd - 回到上一次的目录，我们在“/etc”目录跳转到“/home”目录，所以这次是回到“/etc”目录&lt;/p&gt;

&lt;p&gt;cd ~ “~”代表当前用户的“$HOME”目录，也就是“/home/{用户名}”目录。&lt;/p&gt;

&lt;p&gt;ls 在任何时候，您都可以使用“ls”命令，来了解当前目录下都有哪些文件。&lt;/p&gt;

&lt;p&gt;远程路径：&lt;/p&gt;

&lt;p&gt;远程路径的表示方法为 协议://用户名:密码@位置/路径:端口&lt;/p&gt;

&lt;p&gt;大多数的远程路径可以使用默认端口匿名访问，由此用户名、密码、端口通常不需要填写。例如：&lt;/p&gt;

&lt;p&gt;http://www.ubuntu.org.cn/…/index.html&lt;/p&gt;

&lt;p&gt;要求身份验证的远程路径，您可以使用下面的方式访问:&lt;/p&gt;

&lt;p&gt;ftp://user:passwd@ftp.ubuntu.org.cn:21&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;软件&lt;/h2&gt;

&lt;p&gt;Linux中没有注册表这个概念。安装软件，理论上讲，只要拷贝所有相关文件，并运行它的主程序就可以了。&lt;/p&gt;

&lt;p&gt;按照传统，一个软件通常分别拷贝到同级目录下的 bin、etc、lib、share等文件夹。&lt;/p&gt;

&lt;p&gt;Bin            可执行文件，程序的可执行文件通常在这个目录下。在环境变量中设定搜索路径，就可以直接执行，而不需要定位其路径。&lt;/p&gt;

&lt;p&gt;Etc             配置文件，大部分系统程序的配置文件保存于 /etc 目录，便于集中修改。&lt;/p&gt;

&lt;p&gt;Lib             库文件，集中在一起，方便共享给不同程序。相较不同的软件单独保存库文件，能够节约一些磁盘空间。&lt;/p&gt;

&lt;p&gt;Share        程序运行所需要的其它资源，例如图标、文本。这部分文件是专有的，不需要共享；而且目录结构相对复杂，混放在一起比较混乱，所以单独存放。&lt;/p&gt;

&lt;p&gt;还有一些软件，占用一个单独的目录，所有的资源都在这个目录中。类似于Windows下的绿色软件，不推荐在Linux系统下这样作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;执行时，系统找不到可执行文件（搜索所有路径，资源开销过大，是不现实的），需要定位其位置，像这样 /home/user/bin/可执行文件 ，不够方便。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;许多系统软件需要协作运行，配置文件分别保存，定位它们非常麻烦&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果程序使用的库文件，像图形库文件，都单独存放，那么磁盘空间的浪费会非常严重。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有一些大型软件，或者您布署的重要应用，您可以将它们单独安装在一个文件夹下。（通常源码安装支持这种方式，将在 软件安装 部分介绍）&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;配置方式&lt;/h2&gt;

&lt;p&gt;Linux下没有类似 注册表 的系统，系统和软件都可以通过纯文本的配置文件进行设置。&lt;/p&gt;

&lt;p&gt;事实上，图形界面的配置工具，通常就是以图形界面的方式修改配置文件，适合设置一些比较简单的程序。如果软件有几千个可以配置的选项，全部作成菜单，想象一下……开始发抖吧……&lt;/p&gt;

&lt;p&gt;图形界面的配置工具，可以看作特定配置文件专用编辑器。您一样可以使用通用文本编辑器来编辑配置文件，比如 Nano、Gedit、Knote、Vim或者Emacs等等。不考虑阅读、修改配置文本占用的时间，直接修改配置文件甚至更迅速。&lt;/p&gt;

&lt;p&gt;如果只是要修改某一常用选项，而且时常修改，比如主机的IP地址。使用文本编辑器，您要找到相应的配置文件，还要在配置文件中找到相应的选项，会浪费掉您的时间和耐性。&lt;/p&gt;

&lt;p&gt;图形配置工具经常会受各种因素制约，比如网络服务器中不提供图形服务，图形界面不够稳定……这时，您可以使用命令行的配置工具来完成这些工作。&lt;/p&gt;

&lt;p&gt;例如： 修改主机IP地址，可以使用ifconfig这个程序，执行下面的命令：&lt;/p&gt;

&lt;p&gt;ifconfig eth0 192.168.0.1&lt;/p&gt;

&lt;p&gt;在以后的章节中，如果我们提示您修改某一文件，例如 /etc/fstab ，您可以使用任何顺手的文本编辑器打开它。&lt;/p&gt;

&lt;p&gt;隐藏文件&lt;/p&gt;

&lt;p&gt;Linux下，名称中第一个字符为 . 的文件或者文件夹，系统默认情况下将它们隐藏起来，&lt;/p&gt;

&lt;p&gt;您可以尝试以下操作：&lt;/p&gt;

&lt;p&gt;cd ~ 进入您的用户目录&lt;/p&gt;

&lt;p&gt;ls 查看当前目录下的文件列表&lt;/p&gt;

&lt;p&gt;ls -a 查看所有文件的文件列表（包括隐藏文件）。&lt;/p&gt;

&lt;p&gt;现在，您可以看到许多文件名以 . 起始的文件或者文件夹了吧？使用 ls 命令无法显示它们&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果您只想查看隐藏文件，而不包括这两个特殊目录，您可以使用 ls 命令的参数 -A （ls -A）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个目录下都包含两个特殊目录 . 和 .. 。您也许猜到了， . 代表当前目录， .. 代表上一级目录。目录是一种特殊类型的文件！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;文件类型&lt;/h2&gt;

&lt;p&gt;Linux系统主要根据文件头信息来判断文件类型，扩展名并非决定因素。&lt;/p&gt;

&lt;p&gt;现在使用 ls -l 命令，查看详细信息格式的文件列表，您将会看到如下内容：&lt;/p&gt;

&lt;p&gt;total 5&lt;/p&gt;

&lt;p&gt;drwxr-x— 4 user group 4096 Mar 10 00:37 filename&lt;/p&gt;

&lt;p&gt;drwxr-xr-x 21 user group 4096 Mar 10 20:16 文件名&lt;/p&gt;

&lt;p&gt;-rw——- 1 user group 524 Mar 10 00:40 a&lt;/p&gt;

&lt;p&gt;-rw-r–r– 1 user group 24 Jun 11 2000 b&lt;/p&gt;

&lt;p&gt;drwx—— 2 user group 4096 Mar 9 11:06 c&lt;/p&gt;

&lt;p&gt;共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称&lt;/p&gt;

&lt;p&gt;其中要特别留意的是第一列：&lt;/p&gt;

&lt;p&gt;drwxr-xr-x&lt;/p&gt;

&lt;p&gt;一共有10个位置，可以分为4组：&lt;/p&gt;

&lt;p&gt;d      rwx   r-x   r-x&lt;/p&gt;

&lt;p&gt;第一组只有一个字符：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;d 文件夹         * - 普通文件               * l 链接              * b 块设备文件          * c 字符设备文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;剩下的3组分别为归属用户、归属群组、其它用户或群组对于该文件的权限。我们看它的格式&lt;/p&gt;

&lt;p&gt;rwx rwx   rwx&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;r 可读             * w 可写            * x 可执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它们的顺便不能颠倒，某一位置为空(-)，则表示不具有相应的权限。&lt;/p&gt;

&lt;p&gt;说明：Linux下的可执行文件并不是由扩展名（例如 .exe ）决定的，而是由其可执行权限位决定。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;权限&lt;/h2&gt;

&lt;p&gt;我们已经知道了，文件的权限分为 r （可读）、 w （可写）、 x （可执行）三种类型，而一个文件可以针对归属用户，归属群组，其它用户用户或群组分别设定权限。&lt;/p&gt;

&lt;p&gt;这种权限管理的方式灵活、简单、严密、明晰。尽管如此，在最初的阶段，可能会有一点小小的不适。因为它无所不在，而您习惯了的Windows的权限管理却不是这样（非常混乱，大多数时间形同虚设，偶尔用到却让人伤透脑筋）。&lt;/p&gt;

&lt;p&gt;使用 chmod 命令更改文件的权限，使用 chown 来更改文件的归属。例如：&lt;/p&gt;

&lt;p&gt;chmod 755 xxx&lt;/p&gt;

&lt;p&gt;chmod a+x xxx&lt;/p&gt;

&lt;p&gt;chown user:group xxx 用来更改文件的归属用户，也可以同时更改其归属群组&lt;/p&gt;

&lt;p&gt;chgrp group xxx 用来更改文件的归属群组&lt;/p&gt;

&lt;p&gt;上面命令中的 755 和 a+x 是两种类型的表达式&lt;/p&gt;

&lt;p&gt;我们将后面章节中详细介绍 权限管理 用户管理&lt;/p&gt;

&lt;p&gt;执行命令的权限&lt;/p&gt;

&lt;p&gt;有一些命令，普通用户也可以执行，但是只有root用户才能执行成功，这是为什么呢？&lt;/p&gt;

&lt;p&gt;例如在系统中增加一个新用户 useradd&lt;/p&gt;

&lt;p&gt;ls -l /usr/sbin/useradd&lt;/p&gt;

&lt;p&gt;可以看到：&lt;/p&gt;

&lt;p&gt;-rwxr-xr-x 1 root root 56156 2006-04-03 21:37 /usr/sbin/useradd&lt;/p&gt;

&lt;p&gt;明明所有的用户都可以执行嘛？&lt;/p&gt;

&lt;p&gt;这是因为， useradd 命令是修改 /etc/passwd 文件的一个工具，来看看这个文件：&lt;/p&gt;

&lt;p&gt;ls -l /etc/passwd&lt;/p&gt;

&lt;p&gt;-rw-r–r– 1 root root 1835 2006-06-24 17:58 /etc/passwd&lt;/p&gt;

&lt;p&gt;原来只有root用户才能写入修改结果，非root用户执行 useradd 命令当然不会有结果。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;执行命令的身份&lt;/h2&gt;

&lt;p&gt;默认情况下，您的命令提示符末位为 $ ，这表示您将以普通用户的身份执行命令。&lt;/p&gt;

&lt;p&gt;您可以使用 su （switch user）这个命令来切换其它用户。&lt;/p&gt;

&lt;p&gt;例如 su root ，切换到root用户，如果 su 命令后面没有切换目标，那么这个命令默认切换到root用户。&lt;/p&gt;

&lt;p&gt;现在您执行 su 这个命令，系统会提示您输入密码，请输入管理员的密码。这个时候，您会发现命令提示符末位变成了 # ，您将以root用户的身份执行命令。&lt;/p&gt;

&lt;p&gt;Ubuntu系统默认会随机设定系统的root密码，这样会更安全一些，这个时候您可以执行“sudo”命令，输入当前用户密码后，暂时以root&lt;/p&gt;

&lt;p&gt;用户的身份执行命令。（前提是sudoer列表中要包含您的ID。您在安装Ubuntu系统时创建的用户，默认具有“sudo”权限）&lt;/p&gt;

&lt;p&gt;如果您能够执行“sudo”命令，那么您也就拥有了root权限。在后面的章节中，如果我们提到了“root权限”，那么您可以通过以上两种方式来实现&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;命令行&lt;/h2&gt;
&lt;p&gt;Shell、Console、Terminal&lt;/p&gt;

&lt;p&gt;在前面的章节中，我们曾提到，电视机的遥控器，也是一种人机交互的界面，算是一种Shell。&lt;/p&gt;

&lt;p&gt;但是这个概念并不准确，遥控器只是向Shell发送指令的工具，Shell接收到遥控器发出指令后，将指令转换为系统命令，由系统来执行。&lt;/p&gt;

&lt;p&gt;例如我们按的遥控器上的 数字键1 ,遥控器将 切换为1频道 的指令发送到Shell，Shell将指令转换为系统可以识别的 频道1 ，系统执行它，您就可以观看1频道的电视节目了。&lt;/p&gt;

&lt;p&gt;通常每台电视机只有一种Shell，比如有的电视机系统具有“画中画”的功能，那么Shell中便有相应的功能定义，您可以通过遥控器上的“画中画”功能键来开启它。假设您的电视机没有此功能，Shell中也就没有相应的功能定义。拥有一个带“画中画”功能控制键的遥控器，即便信号兼容，您还是不能够使用这一功能：）&lt;/p&gt;

&lt;p&gt;不用遥控器也可以控制电视机，假设您的遥控器丢了，您还可以走到电视机前，使用机身上的控制面板来控制它（相当于使用Linux的控制台）。但是您一定不喜欢这种方式，除非您想锻炼身体：）&lt;/p&gt;

&lt;p&gt;在Linux系统中，由于图形界面和控制台的分辨率通常不一致，所以切换时要有一个延时。对于我们中文用户来讲，控制台下中文的显示也比较麻烦。而且控制台显示内容通常不如终端显示的全面。&lt;/p&gt;

&lt;p&gt;所以我们推荐您使用终端来执行命令，它使用起来感觉很像遥控器：）&lt;/p&gt;

&lt;p&gt;rxvt-unicode&lt;/p&gt;

&lt;p&gt;通常情况下，您买一台电视机，只能获得一个遥控器。虽然它为您的电视机量身定作，能够最大限度发挥电视机的能力，但您却不一定喜欢它。说不定这个遥控器体形太大，持握不方便;或者它体形太小，容易失踪;又或者它的按键要么太硬，要么太软;它的键盘要么太大，要么太小……您一般也可以容忍，毕竟遥控器使用频率并不算高：）&lt;/p&gt;

&lt;p&gt;如果您的终端有些地方不讨您喜欢，比如说响应太慢，或者不能正常显示中文……那就难以忍受了，您应该换一个其它的试试。&lt;/p&gt;

&lt;p&gt;在前面的章节，我们介绍您使用的终端为Gnome-Termianl，它是系统默认使用的终端，显示中文不错，不过响应比较慢，您可能已经处于水深火热之中了。。。&lt;/p&gt;

&lt;p&gt;我们推荐您使用urxvt（mlterm也是不错的选择）&lt;/p&gt;

&lt;p&gt;您可以使用 sudo apt-get install rxvt-unicode 命令来安装它。&lt;/p&gt;

&lt;p&gt;urxvt 启动它 （urxvt不支持控制台，您得在图形界面下启动它。终端、Alt+F2，建议您在启动栏里新建一个启动图标）&lt;/p&gt;

&lt;p&gt;rxvt-unicode还支持“服务器/客户端”的运行模式：&lt;/p&gt;

&lt;p&gt;urxvtd 启动一个守护进程daemon（支持控制台）&lt;/p&gt;

&lt;p&gt;urxvtc 启动客户端client。多个客户端可以同时连接到一个urxvtd，以达到节省系统资源的目的。&lt;/p&gt;

&lt;p&gt;或许您对rxvt的默认设置不满意，您可以修改用户配置文件 ~/.Xresources 来设定它。修改全局配置文件 /etc/X11/Xresources/Xresources ，则对所有用户生效，只有root才可以修改此文件。&lt;/p&gt;

&lt;p&gt;这里有一些简单的选项：（以 ! 起始的行是注释，您可以直接拷贝此文件的内容）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!!=============================================================================

!! RXVT-unicode setting

!!=============================================================================

!设置字体分辨率

Xft.dpi:96

!窗口大小

Rxvt.geometry: 80x40+80+80

!颜色

Rxvt.background:#333333

Rxvt.foreground:antiquewhite

Rxvt.inheritPixmap:False

Rxvt.colorBD:yellow

Rxvt.colorUL:antiquewhite

!滚动条

Rxvt.scrollBar:True

Rxvt.scrollBar_left:True

Rxvt.scrollBar_floating:False

Rxvt.scrollstyle:next

Rxvt.scrollColor:#999999

!屏幕缓冲

Rxvt.saveLines:30000

Rxvt.color12:DodgerBlue

Rxvt.font:7x14,xft:AR PL New Sung

!输入法一般设置为xim

!inputMethod:xim;Scim除外

!输入法样式可选:Root(置底) OverTheSpot(跟随) OffTheSpot OnTheSpot，后两种不是所有的都支持

Rxvt.preeditType:Root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tip：右键点击启动栏， 添加自启动器 ， 自定义程序 ，便可以在添加自己的启动图标。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;在线帮助系统&lt;/h2&gt;

&lt;p&gt;您可以使用命令 man 或者 info 来阅读Linux命令的在线文档。命令的格式非常简单：&lt;/p&gt;

&lt;p&gt;man xxx&lt;/p&gt;

&lt;p&gt;大部分命令手册为英文版，如果您的英文不太好，或许有些困难。在后面的 系统管理 章节中，我们会尽力向您介绍命令的使用方法。&lt;/p&gt;

&lt;p&gt;说明：在使用“man”浏览器的时候，一些快捷键您可能会用到：&lt;/p&gt;

&lt;p&gt;Ctrl+f(orward) 向下翻一页 Ctrl+d(own) 向下翻半页&lt;/p&gt;

&lt;p&gt;Ctrl+b(ackward) 向上翻一页 Ctrl+u(p) 向上翻半页&lt;/p&gt;

&lt;p&gt;/ 查找 q(uit) 退出&lt;/p&gt;

&lt;p&gt;以上为VI风格的键绑定。您也可以使用Emacs风格的键绑定&lt;/p&gt;

&lt;h2 id=&quot;bash&quot;&gt;bash&lt;/h2&gt;

&lt;p&gt;好了，现在我们换了一个遥控器，感觉顺手多了。现在来操练一下，下载一首mp3：&lt;/p&gt;

&lt;p&gt;我们使用 wget 这个程序，它非常可靠，完全值得您信赖。&lt;/p&gt;

&lt;p&gt;首先找到一个可以下载的地址，复制链接，在终端窗口内点击鼠标中键，把它粘贴进去。&lt;/p&gt;

&lt;p&gt;现在终端中大概是这种情形：&lt;/p&gt;

&lt;p&gt;http://www.download.net/xxx.mp3&lt;/p&gt;

&lt;p&gt;按下 Ctrl+a 组合键，我们发现光标移动到了行首。输入 wget 和 空格&lt;/p&gt;

&lt;p&gt;wget http://www.download.net/xxx.mp3&lt;/p&gt;

&lt;p&gt;回车后，终端中出现一些信息，不一会儿工夫，mp3便下载完成。&lt;/p&gt;

&lt;p&gt;使用 Ctrl+a 组合键，我们就不需要使用方向键来移动光标，方向键每次只能移动一个字符，没有效率&lt;/p&gt;

&lt;p&gt;您还可以使用 Ctrl+f 向前移动光标， Ctrl+b 向后移动光标， Ctrl+e 将光标移动到行末……………… （键绑定）&lt;/p&gt;

&lt;h2 id=&quot;note&quot;&gt;Note&lt;/h2&gt;

&lt;p&gt;Linux的图形界面中，鼠标中键通常执行“粘贴”的操作，如果您的鼠标没有中键，您可以左右键同时按下。&lt;/p&gt;

&lt;p&gt;中止正在运行的程序&lt;/p&gt;

&lt;p&gt;如果一个命令持续时间很长，以致于不能够进行其它操作，可以使用 Ctrl+c 来强行中止它。&lt;/p&gt;

&lt;p&gt;Ctrl+s&lt;/p&gt;

&lt;p&gt;出于意外，有时您会按下 Ctrl+s 这个组合键，Shell便被冻结。尝试使用 Ctrl+q 组合键，看能否恢复正常。&lt;/p&gt;

&lt;p&gt;键绑定&lt;/p&gt;

&lt;p&gt;等等，有必要记这么多快捷键么？都这么复杂！&lt;/p&gt;

&lt;p&gt;我们强烈建议您记住，以大幅度的提高操作效率。而且这是readline控件的键绑定，在任何使用readline控件的程序中，您都可以使用它们。例如bash、lftp、gdb等程序;同时，Linux下最著名的Emacs编辑器，也是这种风格的键绑定（其实是readline使用了Emacs风格的键绑定才对），甚至FireFox中，也可以使用类似风格的快捷键！（Linux下主要有两种风格的键绑定，一种是VI风格，另一种是Emacs风格，我们会在 简明VIM教程中介绍）&lt;/p&gt;

&lt;p&gt;现在列举一些ReadLine的键绑定，您可以自行尝试。（运行 man readline 命令，来查看ReadLine手册）&lt;/p&gt;

&lt;p&gt;先来了解一些约定：&lt;/p&gt;

&lt;p&gt;\C-a 表示 Ctrl+a&lt;/p&gt;

&lt;p&gt;\M-a 表示 Meta+a Meta键在PC中通常为ALT键&lt;/p&gt;

&lt;p&gt;A 表示 Shift+a&lt;/p&gt;

&lt;p&gt;（下面括号中的\A代表Alt，\S代表Shift）&lt;/p&gt;

&lt;p&gt;移动命令：&lt;/p&gt;

&lt;p&gt;\C-a 移动到行首 Aheah               \C-e 移动到行末 End                   \C-f 向前移动一个字符 Forward&lt;/p&gt;

&lt;p&gt;\C-b 向后移动一个字符 Backward               \M-f 向前移动一个单词               \M-b 向后移动一个单词&lt;/p&gt;

&lt;p&gt;\C-l 清空屏幕 cLear           这两个命令也可以理解为移动命令               \C-p 上翻，前一条命令 Previous&lt;/p&gt;

&lt;p&gt;\C-n 下翻，后一条命令 Next               编辑命令：&lt;/p&gt;

&lt;p&gt;\C-d 删除光标后的一个字符 \M-d 删除光标后的一个单词 Delete&lt;/p&gt;

&lt;p&gt;\BackSpace 删除光标前的一个字符 \M-BackSpace 删除光标前的一个单词&lt;/p&gt;

&lt;p&gt;\C-k 删除光标至行末的部分 Kill                  \C-u 删除光标至行首的部分 Unix-line-discard&lt;/p&gt;

&lt;p&gt;\C-w 删除光标前的一个单词 Word              \C-y 粘贴（最后删除的对象） Yank            \C– 撤消&lt;/p&gt;

&lt;p&gt;搜索历史纪录：&lt;/p&gt;

&lt;p&gt;\C-r 连续使用 &lt;code&gt;C-r&lt;/code&gt; 可以查找下一个                \M-p           \M-n&lt;/p&gt;

&lt;p&gt;补全：&lt;/p&gt;

&lt;p&gt;\Tab 使用频率最高的功能！                \C-o 遍历补全 （未定义）&lt;/p&gt;

&lt;p&gt;\M-? M-= 列出所有可能选项，相当于按两次Tab键（M-？ 实际按键为\A+\S+/）&lt;/p&gt;

&lt;p&gt;\M-# 注释掉当前命令，用于将当前命令暂存于历史纪录列表（\A+\S+3）&lt;/p&gt;

&lt;p&gt;\M-! 补全命令，通常用来补全子命令，例如 &lt;code&gt;sudo&lt;/code&gt; 的子命令（\A+\S+1）&lt;/p&gt;

&lt;p&gt;\M-~ 补全用户名（\A+\S+`）              \M-@ 补全主机名（\A+\S+2）&lt;/p&gt;

&lt;p&gt;\M-$ 补全变量（\A+\S+4）                  \M-_ 补全历史纪录中的纪录（\A+\S+-）&lt;/p&gt;

&lt;p&gt;\M-* 将所有可能选项放到命令行中（\A+\S+8）&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;自定义键绑定&lt;/h2&gt;

&lt;p&gt;通过修改 /etc/inputrc 文件，可以更改键绑定。建议您使用默认的键绑定，以避免不必要的烦恼。当然了，Emacs风格的键绑定是通用的，随时都有可能用到。&lt;/p&gt;

&lt;p&gt;在文件中添加该行，可以将ReadLine的键绑定设为VI风格。（Bash、Lftp等使用ReadLine的软件同时生效）&lt;/p&gt;

&lt;p&gt;set editing-mode vi&lt;/p&gt;

&lt;p&gt;找到这一行：&lt;/p&gt;

&lt;p&gt;$if mode=emacs&lt;/p&gt;

&lt;p&gt;在它的下面添加如下内容&lt;/p&gt;

&lt;p&gt;“\C-o”: menu-complete&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;这两行不是必须的，视情况而定&lt;/h3&gt;

&lt;p&gt;“\c-p”: non-incremental-reverse-search-history&lt;/p&gt;

&lt;p&gt;“\c-n”: non-incremental-forward-search-history&lt;/p&gt;

&lt;p&gt;重新登录Shell，您就可以使用 \C-o （Ctrl+o）来遍历补全。假如您的文件名为中文，或者出现乱码时，您可以使用 \M-*&lt;/p&gt;

&lt;p&gt;将所有文件名放入命令行，再删除多余的，这真是麻烦极了！所以您可以使用 \C-o 遍历补全，将所有可能的选项轮流放入命令行。&lt;/p&gt;

&lt;p&gt;或者使用Vim编辑器编辑 /etc/inputrc 文件，在插入模式下使用 Ctrl+v 组合键。按下 Ctrl+o ，这时编辑区新增一个 ^O 字符，等价于 \C-o&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;通配符&lt;/h2&gt;

&lt;p&gt;使用 ? 代表任意单个字符。例如 ???lo ，表示 lo 前有三个字符，它可以匹配 Hello&lt;/p&gt;

&lt;p&gt;使用 * 代表随意几个任意字符。例如 *.iso ，代表所有iso格式的文件。&lt;/p&gt;

&lt;p&gt;说明：您可以将遍历补全和通配符结合使用，以提高效率。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;cd */ 则遍历补全只补全文件夹&lt;/p&gt;

&lt;p&gt;chmview *.chm 则遍历补全只补全chm文件&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;任务管理&lt;/h2&gt;

&lt;p&gt;1、	&amp;amp;——————————–在命令的末尾加上一个 &amp;amp; 符号，表示背景任务，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	wget http://www.download.net/xxx/mp3 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、	;——————————–使用 ; 将多个命令连结起来，则表示任务按顺序执行.&lt;/p&gt;

&lt;p&gt;3、	&amp;amp;&amp;amp;——————————-使用 &amp;amp;&amp;amp; 将多个命令连结起来，则表示只有前面的命令执行成功，后面的命令才能得以执行.&lt;/p&gt;

&lt;p&gt;4、	` `———————————–`&lt;命令&gt;\` ，如果一个命令中包含以 `` （Esc键下方的按键）括起来的子命令，那么子命令将被优先执行，执行结果被代入上一级命令继续执行，例如创建一个以当前时间命名的文件：&lt;/命令&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch `date +%m.%d_%H:%M:%S`

touch 命令能够创建一个文件，它的操作对象，为 date +%m%d%H%M%S 命令的输出 06.06_06:06:60

这样，我们创建了一个名为 06.06_06:06:60 的文件（六月六日六时六分刚过六十秒-_-!）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ctrlz&quot;&gt;Ctrl+z&lt;/h2&gt;

&lt;p&gt;将当前Shell中的任务挂起&lt;/p&gt;

&lt;p&gt;这个时候任务的状态为&lt;/p&gt;

&lt;p&gt;[1]+ Stopped xxx&lt;/p&gt;

&lt;p&gt;Bg————————————————-将挂起的任务背景运行。这时它的状态为[1]+ xxx &amp;amp;&lt;/p&gt;

&lt;p&gt;Fg————————————————-将背景任务调到前台执行jobs&lt;/p&gt;

&lt;p&gt;方括号中的数字为命令的任务编号，您可以使用 jobs 命令来查看所有背景任务&lt;/p&gt;

&lt;p&gt;如果后台运行多个任务，您可以在 bg 或者 fg 后跟任务编号，作为操作对象，例如：bg 2&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;管道、重定向&lt;/h2&gt;

&lt;p&gt;1、 &amp;gt;———————–重定向符号，它的作用是将命令的输出重定向到一个文件中。比如我
们想把命令 ls 的结果保存为 FileList 文件，作一个清单，我们可以使用重定向符号来完成它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -l &amp;gt; FileList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、 »———————-作用与 &amp;gt; 基本相同，不同点在于， » 以追加的方式，将命令的输
出写入文件的末尾。&lt;/p&gt;

&lt;p&gt;3、 &amp;lt;———————–是从文件到命令的重定向，将文件的内容作为命令的输入。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4、&lt;/td&gt;
      &lt;td&gt;———————–为管道符号，它的作用是将前一个命令的输出，作为下一个命令的输&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;入。假设一个目录下的文件太多，使用 ls命令不能够在屏幕中完全显示，这个时候您可以将 ls 命令的输出，通过管道符号，作为浏览器 less 的输入。就可以使用浏览器的功能翻页、查找：ls -al&lt;/td&gt;
      &lt;td&gt;less&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明： less 浏览器的键绑定几乎与 man 相同，请参阅 在线帮助系统&lt;/p&gt;

&lt;h2 id=&quot;section-15&quot;&gt;脱字符&lt;/h2&gt;

&lt;p&gt;Shell中的一些功能是通过特殊符号作为控制字符来实现的，上面已经介绍了很多了。这产生一个问题，如果一个文件名中，刚好包含了这些字符，比如 ; ，就很难对它进行操作。使用 less 浏览这个文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;less ;xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;less 会很快返回一个错误信息，因为并没有一个文件名作为操作对象。接着，Shell会报告，系统中没有 xxx 这个命令。&lt;/p&gt;

&lt;p&gt;这是因为Shell将文件名中的 ; 解析为按顺序执行命令。&lt;/p&gt;

&lt;p&gt;或者您的文件名以空白起始，而在Shell中，无论多少个空格，都将被解析为一个分隔符。您甚至不是使用命令重命名此文件。&lt;/p&gt;

&lt;p&gt;这个时候就要用到脱字符 \ 了，它能够将一个具有特殊涵义的字符转换普通字符。上面的两个任务，可以在文件名中每个特殊字符前加一个 \ ，像这样&lt;/p&gt;

&lt;p&gt;less \;xxx&lt;/p&gt;

&lt;p&gt;less \ \xxx&lt;/p&gt;

&lt;p&gt;less \;\ \&amp;amp;\xxx&lt;/p&gt;

&lt;p&gt;说明：也可以使用 “ 将文件名括起来，例如 less “; &amp;amp;xxx” ，在很多情况下，这样甚至更方便。&lt;/p&gt;

&lt;p&gt;脱字符在Shell中也可以作为换行符，在一个命令的末尾添加一个 \ ，然后回车，在下一行继续输入命令剩余的部分，将一个命令拆分为多行且不影响它的执行（如果执行一个很长的命令，请将它拆分为多行以便于阅读）&lt;/p&gt;

&lt;p&gt;事实上换行符也符合脱字符的定义。回车键有两个涵义，一个是 执行 （Enter），另一个 换行 （折线箭头）。在Shell中它作为控制字符 执行 ，使用脱字符后，它便代表排版字符 换行 了。&lt;/p&gt;

&lt;h2 id=&quot;fish&quot;&gt;Fish&lt;/h2&gt;

&lt;p&gt;the  friendly  interactive  shell&lt;/p&gt;

&lt;p&gt;正如它的名字，Fish是一款非常友好的Shell，大力推荐！使用命令 sudo apt-get install fish 安装它。完成后，运行命令 fish 切换到fish， exit 返回bash。&lt;/p&gt;

&lt;p&gt;简单介绍一下它的优点：&lt;/p&gt;

&lt;p&gt;1.自动补全、语法高亮&lt;/p&gt;

&lt;p&gt;bash的自动补全默认只是补全命令、路径，如果想补全变量、参数等，通常需要使用复杂的组合键（见上面bash的介绍），即便您能够记住它们，快速准确的按下这些组合键，也是一种严峻的考验。而FISH的自动补全可以自动识别语法，补全正确的内容。并且具有语法高亮的功能，比如用MPLAYER放MP3：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mpl&amp;lt;tab&amp;gt;(ayer) -l&amp;lt;tab&amp;gt;(oop) &amp;lt;tab&amp;gt;(0)

-sh&amp;lt;tab&amp;gt;(uffle) -pl&amp;lt;tab&amp;gt;(aylist) &amp;lt;tab&amp;gt;(mp3_playlist)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一阵猛按”&amp;lt; tab &amp;gt;” 键，一个蛮长的命令就完成了。&lt;/p&gt;

&lt;p&gt;补全结果不唯一时给出的提示中含有简短的说明，这样通常也不用看帮助了：）比如：&lt;/p&gt;

&lt;p&gt;mplayer -l&lt;/p&gt;

&lt;p&gt;”&amp;lt; tab &amp;gt;” 后，自动将参数补全为 -lo 然后给出提示&lt;/p&gt;

&lt;p&gt;-{lo}adidx (Load index from file) -{lo}op (Loop playback) {花括号中为青色文字}&lt;/p&gt;

&lt;p&gt;它的语法高亮功能十分有用，如果你输入的命令是正确的，则用青色显示，正确的参数用白色显示，错误的则一律用红色。&lt;/p&gt;

&lt;p&gt;2.方便的历史纪录搜索&lt;/p&gt;

&lt;p&gt;还是上面的那个命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mplayer -loop 0 -shuffle -playlist mp3_playlist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用上翻配合下翻浏览命令历史，直到找到这个命令，当然那样太慢了。&lt;/p&gt;

&lt;p&gt;还可以输入以上命令中的某一部分，如 uffle 只要翻一次就可以找到了&lt;/p&gt;

&lt;p&gt;（还可以META＋上翻在已输入部分中插入某一历史单词）&lt;/p&gt;

&lt;p&gt;3.文件夹历史纪录&lt;/p&gt;

&lt;p&gt;dirh （dir history）就可以显示当前会话中进入的文件夹纪录&lt;/p&gt;

&lt;p&gt;使用 prevd 和 nextd 跳转&lt;/p&gt;

&lt;p&gt;假如曾进入过1 2 3 4 5 这几个文件夹， prevd 4 可以让你在 5 中直接跳到 1&lt;/p&gt;

&lt;p&gt;4.其它的功能&lt;/p&gt;

&lt;p&gt;fish基本是兼容bash的。键绑定也非常的相似，少数的键绑定不尽一致，例如：&lt;/p&gt;

&lt;p&gt;\C-h 删除光标前的一个字符（bash为退格键，不方便）&lt;/p&gt;

&lt;p&gt;修改 /etc/fish_inputrc 这个文件，增加以下行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;\C-n&quot;: history-search-forward

&quot;\C-p&quot;: history-search-backward
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在使用Ctrl+p上翻，使用Ctrl+n下翻。如果已经在命令行中输入字符，那么Ctrl+p就是在历史纪录向上查找您输入的字符，Ctrl+n为向下查找，非常的方便。&lt;/p&gt;

&lt;p&gt;设定您的默认Shell&lt;/p&gt;

&lt;p&gt;如果能够拥有root权限，可以直接修改 /etc/passwd 文件。找到您用户ID起始的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user:x:1000:112:user,,,:/home/user:/bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一个字段为登录后的默认Shell， /bin/bash 是程序 bash 的主程序路径。 fish 主程序的路径通常为 /usr/bin/fish 。&lt;/p&gt;

&lt;p&gt;/etc/shells 中列出系统中所有可用Shell（ /bin/false 代表禁用Shell）&lt;/p&gt;

&lt;p&gt;也可以使用如下命令更改您的默认Shell&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chsh -s /usr/bin/fish

（需要输入您的密码）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tip：可以使用 whereis xxx 命令，来查找 xxx 程序的安装位置，详见搜索&lt;/p&gt;

&lt;p&gt;设定命令的搜索路径&lt;/p&gt;

&lt;p&gt;使用 echo $PATH ，可以显示 $PATH 变量，输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/bin/X11 /usr/games /usr/X11R6/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它是一个环境变量，代表执行命令时，Shell的搜索路径。&lt;/p&gt;

&lt;p&gt;执行一个命令时，Shell会到 $PATH 变量定义的路径去搜索，并运行与命令同名的可执行文件。如果程序、脚本等可执行文件并不在上面的路径中，就必须使用绝对路径或者相对路径定位可执行文件。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/mplayer -menu xxx.rmvb

/etc/init.d/powernowd start

cd /usr/local/ &amp;amp;&amp;amp; ./mplayer -menu xxx.rmvb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以修改 /etc/environment 文件来设定您的命令搜索路径，找到 PATH 起始的行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在双引号中添加您的自定义路径，并以 : 分隔。&lt;/p&gt;

&lt;h1 id=&quot;ubuntu-4&quot;&gt;Ubuntu系统简介&lt;/h1&gt;
&lt;p&gt;## Ubuntu系统目录结构 ##&lt;/p&gt;

&lt;p&gt;以下为Ubuntu目录的主要目录结构，您稍微了解它们都包含了哪些文件就可以了，不需要记忆。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/ 根目录
	
	│
	
	├boot/ 启动文件。所有与系统启动有关的文件都保存在这里
	
	│ └grub/ Grub引导器相关的文件
	
	│
	
	├dev/ 设备文件
	
	├proc/ 内核与进程镜像
	
	│
	
	├mnt/ 临时挂载
	
	├media/ 挂载媒体设备
	
	│
	
	├root/ root用户的$HOME目录
	
	├home/
	
	│ ├user/ 普通用户的$HOME目录
	
	│ └.../
	
	│
	
	├bin/ 系统程序
	
	├sbin/ 管理员系统程序
	
	├lib/ 系统程序库文件
	
	├etc/ 系统程序和大部分应用程序的全局配置文件
	
	│ ├init.d/ SystemV风格的启动脚本
	
	│ ├rcX.d/ 启动脚本的链接，定义运行级别
	
	│ ├network/ 网络配置文件
	
	│ ├X11/ 图形界面配置文件
	
	├usr/
	
	│ ├bin/ 应用程序
	
	│ ├sbin/ 管理员应用程序
	
	│ ├lib/ 应用程序库文件
	
	│ ├share/ 应用程序资源文件
	
	│ ├src/ 应用程序源代码
	
	│ ├local/
	
	│ │ ├soft/ 用户程序
	
	│ │ └.../ 通常使用单独文件夹
	
	│ ├X11R6/ 图形界面系统
	
	│
	
	├var/ 动态数据
	
	│
	
	├temp/ 临时文件
	
	├lost+found/ 磁盘修复文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-16&quot;&gt;启动流程&lt;/h2&gt;

&lt;p&gt;Linux系统主要通过以下步骤启动：&lt;/p&gt;

&lt;h4 id=&quot;mbrboot-manager&quot;&gt;1.读取MBR的信息，启动Boot Manager&lt;/h4&gt;

&lt;p&gt;Windows使用NTLDR作为Boot&lt;/p&gt;

&lt;p&gt;Manager，如果您的系统中安装多个版本的Windows，您就需要在NTLDR中选择您要进入的系统。&lt;/p&gt;

&lt;p&gt;Linux通常使用功能强大，配置灵活的GRUB作为Boot Manager，我们将在启动管理章节中向您介绍它的使用方式。&lt;/p&gt;

&lt;h4 id=&quot;init&quot;&gt;2.加载系统内核，启动init进程&lt;/h4&gt;

&lt;p&gt;init进程是Linux的根进程，所有的系统进程都是它的子进程。&lt;/p&gt;

&lt;h4 id=&quot;init-etcinittab--start-&quot;&gt;3.init进程读取 /etc/inittab 文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以 start 参数启动，并指向一个系统中的程序。&lt;/h4&gt;

&lt;p&gt;通常情况下， /etc/rcS.d/ 目录下的启动脚本首先被执行，然后是 /etc/rcN.d/ 目录。例如您设定的运行级别为3,那么它对应的启动目录为 /etc/rc3.d/ 。&lt;/p&gt;

&lt;h4 id=&quot;etcrcsd-xwindow-xorg&quot;&gt;4.根据 /etc/rcS.d/ 文件夹中对应的脚本启动Xwindow服务器 xorg&lt;/h4&gt;

&lt;p&gt;Xwindow为Linux下的图形用户界面系统。&lt;/p&gt;

&lt;h4 id=&quot;section-17&quot;&gt;5.启动登录管理器，等待用户登录&lt;/h4&gt;

&lt;p&gt;Ubuntu系统默认使用GDM作为登录管理器，您在登录管理器界面中输入用户名和密码后，便可以登录系统。（您可以在 /etc/rc3.d/ 文件夹中找到一个名为 S13gdm 的链接）&lt;/p&gt;

&lt;p&gt;更改运行级别&lt;/p&gt;

&lt;p&gt;在 /etc/inittab 文件中找到如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# The default runlevel.

id:2:initdefault:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一行中的数字 2 ,为系统的运行级别，默认的运行级别涵义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 关机       1 单用户维护模式         2~5 多用户模式         6 重启
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-18&quot;&gt;服务管理&lt;/h1&gt;

&lt;h2 id=&quot;section-19&quot;&gt;更改启动服务&lt;/h2&gt;

&lt;p&gt;在运行级别对应的文件夹中，您可以看到许多文件名以 S## 和 K## 起始的启动脚本链接。例如：&lt;/p&gt;

&lt;p&gt;/etc/rcS.d/S35mountall.sh 挂载文件系统&lt;/p&gt;

&lt;p&gt;/etc/rcS.d/S40networking 启用网络支持&lt;/p&gt;

&lt;p&gt;/etc/rc2.d/S13gdm 启动登录管理器&lt;/p&gt;

&lt;p&gt;/etc/rc2.d/S20makedev 创建设备文件&lt;/p&gt;

&lt;p&gt;/etc/rc2.d/S23xinetd 启动超级进程&lt;/p&gt;

&lt;p&gt;init进程将以 start 为参数，按文件名顺序执行所有以 S## 起始的脚本。脚本名称中的数字越小，它将被越早执行。例如在&lt;/p&gt;

&lt;p&gt;/etc/rc2.d/ 文件夹中， S13gdm 文件名中的数字小于 S23xinetd , S13gdm 将比 S23xinetd 先执行。&lt;/p&gt;

&lt;p&gt;如果一个脚本链接，以 K## 起始，表示它将以 stop 参数被执行。如果相应服务没有启动，则不执行该脚本。例如：&lt;/p&gt;

&lt;p&gt;/etc/rc2.d/K20powernowd 针对某种硬件的电源管理支持&lt;/p&gt;

&lt;p&gt;如果您想禁止某一服务在启动时自动运行，您可以将相应运行级别中的脚本由 S##xxx 重命名为 K##xxx 。&lt;/p&gt;

&lt;h2 id=&quot;section-20&quot;&gt;手动控制服务&lt;/h2&gt;

&lt;p&gt;您也可以手动运行带有以下参数的启动脚本，来控制系统服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- start 启动      - stop 停止      - restart 重启
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;/etc/rc2.d/K20powernowd start&lt;/p&gt;

&lt;p&gt;有时您并不清楚当前运行级别，该运行级别下未必有相应脚本；而且此类脚本的前三位字符并不固定，不便于记忆。这时，可以直接使用&lt;/p&gt;

&lt;p&gt;/etc/init.d/ 文件夹中的启动脚本（ /etc/rcX.d/ 中的启动脚本链接到 /etc/init.d/&lt;/p&gt;

&lt;p&gt;文件夹下相应脚本），这也是推荐的方式。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;/etc/init.d/powernowd start&lt;/p&gt;

&lt;p&gt;Note：以上命令的位置并没有包含在环境变量的搜索路径中，所以要输入完整路径。&lt;/p&gt;

&lt;h2 id=&quot;section-21&quot;&gt;常用系统服务&lt;/h2&gt;

&lt;p&gt;acpi-support 高级电源管理支持          acpid acpi守护程序.这两个用于电源管理，非常重要&lt;/p&gt;

&lt;p&gt;alsa 声音子系统                   alsa-utils&lt;/p&gt;

&lt;p&gt;anacron cron的子系统，将系统关闭期间的计划任务，在下一次系统运行时执行。&lt;/p&gt;

&lt;p&gt;apmd acpi的扩展                 atd 类似于cron的任务调度系统。建议关闭&lt;/p&gt;

&lt;p&gt;binfmt-support 核心支持其他二进制的文件格式。建议开启                  bluez-utiles 蓝牙设备支持&lt;/p&gt;

&lt;p&gt;bootlogd 启动日志。开启它                 cron 任务调度系统，建议开启&lt;/p&gt;

&lt;p&gt;cupsys 打印机子系统。              dbus 消息总线系统(message bus system)。非常重要&lt;/p&gt;

&lt;p&gt;dns-clean 使用拨号连接时，清除dns信息。                &lt;/p&gt;

&lt;p&gt;evms 企业卷管理系统（Enterprise Volumn Management system）&lt;/p&gt;

&lt;p&gt;fetchmail 邮件用户代理守护进程，用于收取邮件                  gdm gnome登录和桌面管理器。&lt;/p&gt;

&lt;p&gt;Gdomap              gpm 终端中的鼠标支持。           halt 别动它。&lt;/p&gt;

&lt;p&gt;hdparm 调整硬盘的脚本，配置文件为 /etc/hdparm.conf。             hibernate 系统休眠&lt;/p&gt;

&lt;p&gt;hotkey-setup 笔记本功能键支持。支持类型包括： HP, Acer, ASUS, Sony, Dell, 和IBM&lt;/p&gt;

&lt;p&gt;hotplug and hotplug-net 即插即用支持，比较复杂，建议不要动它&lt;/p&gt;

&lt;p&gt;hplip HP打印机和图形子系统             ifrename 网络接口重命名脚本。如果您有十块网卡，您应该开启它&lt;/p&gt;

&lt;p&gt;inetd 在文件 /etc/inetd.conf 中，注释掉所有你不需要的服务。如果该文件不包含任何服务，那关闭它是很安全的。              klogd 重要。&lt;/p&gt;

&lt;p&gt;linux-restricted-modules-common 受限模块支持。 /lib/linux-restricted-modules/ 文件夹中的模块为受限模块。例如某些驱动程序，如果您没有使用受限模块，就不需要开启它。&lt;/p&gt;

&lt;p&gt;lvm 逻辑卷管理系统支持。                 makedev 创建设备文件，非常重要。           mdamd 磁盘阵列&lt;/p&gt;

&lt;p&gt;module-init-tools 从/etc/modules加载扩展模块，建议开启。&lt;/p&gt;

&lt;p&gt;networking 网络支持。按 /etc/network/interfaces 文件预设激活网络，非常重要。&lt;/p&gt;

&lt;p&gt;ntpdate 时间同步服务，建议关闭。            pcmcia pcmcia设备支持。           powernowd 移动CPU节能支持&lt;/p&gt;

&lt;p&gt;ppp and ppp-dns 拨号连接                   readahead 预加载库文件。          reboot 别动它            &lt;/p&gt;

&lt;p&gt;resolvconf 自动配置DNS            rmnologin 清除nologin                 rsync rsync守护程序&lt;/p&gt;

&lt;p&gt;sendsigs 在重启和关机期间发送信号           single 激活单用户模式                 ssh ssh守护程序。建议开启&lt;/p&gt;

&lt;p&gt;stop-bootlogd 在2，3，4，5运行级别中停止bootlogd服务                   sudo 检查sudo状态。重要&lt;/p&gt;

&lt;p&gt;sysklogd 系统日志              udev &amp;amp; udev-mab 用户空间dev文件系统（userspace dev filesystem）。重要&lt;/p&gt;

&lt;p&gt;umountfs 卸载文件系统               urandom 随机数生成器                usplash 开机画面支持&lt;/p&gt;

&lt;p&gt;vbesave 显卡BIOS配置工具。保存显卡的状态            xorg-common 设置X服务ICE socket。&lt;/p&gt;

&lt;p&gt;adjtimex 调整核心时钟的工具              dirmngr 证书列表管理工具,和gnupg一起工作。&lt;/p&gt;

&lt;p&gt;hwtools irqs优化工具                   libpam-devperm 系统崩溃之后，用于修理设备文件许可的守护程序。&lt;/p&gt;

&lt;p&gt;lm-sensors 板载传感器支持                  mdadm-raid 磁盘陈列管理器               &lt;/p&gt;

&lt;p&gt;screen-cleanup 清除开机屏幕的脚本             xinetd 管理其他守护进程的一个inetd超级守护程序&lt;/p&gt;

&lt;h2 id=&quot;section-22&quot;&gt;重要配置文件&lt;/h2&gt;

&lt;p&gt;！无论任何情况下，修改配置文件之前，先备份它！&lt;/p&gt;

&lt;p&gt;建议使用这个命令： sudo cp xxx xxx_&lt;code&gt;date +%y%m%d_%H:%M&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;当然这很麻烦，您可以新建一个名为 bak 的文件，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

sudo cp $1 $1_`date +%y%m%d_%H:%M`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把它放在您能够记住的目录下，比如 /home ，执行命令 sh /home/bak xxx ，就可以将当前文件夹下的文件 xxx 另存为 xxx_yymmdd_HH:MM 的格式了&lt;/p&gt;

&lt;h1 id=&quot;section-23&quot;&gt;全局配置文件&lt;/h1&gt;

&lt;h2 id=&quot;section-24&quot;&gt;系统初始化&lt;/h2&gt;

&lt;p&gt;/etc/inittab 运行级别、控制台数量                /etc/timezone 时区               /etc/inetd.conf ## 超级进程 ##&lt;/p&gt;

&lt;h2 id=&quot;section-25&quot;&gt;文件系统&lt;/h2&gt;

&lt;p&gt;/etc/fstab 开机时挂载的文件系统                  /etc/mtab 当前挂载的文件系统&lt;/p&gt;

&lt;h2 id=&quot;section-26&quot;&gt;用户系统&lt;/h2&gt;

&lt;p&gt;/etc/passwd 用户信息                   /etc/shadow 用户密码                   /etc/group 群组信息&lt;/p&gt;

&lt;p&gt;/etc/gshadow 群组密码                 /etc/sudoers Sudoer列表（请使用“visudo”命令修改此文件，而不要直接编辑）&lt;/p&gt;

&lt;h2 id=&quot;shell&quot;&gt;Shell&lt;/h2&gt;

&lt;p&gt;/etc/shell 可用Shell列表              /etc/inputrc ReadLine控件设定              /etc/profile 用户首选项&lt;/p&gt;

&lt;p&gt;/etc/bash.bashrc bash配置文件&lt;/p&gt;

&lt;h2 id=&quot;section-27&quot;&gt;系统环境&lt;/h2&gt;

&lt;p&gt;/etc/environment 环境变量           /etc/updatedb.conf 文件检索数据库配置信息                  /etc/issue 发行信息&lt;/p&gt;

&lt;p&gt;/etc/issue.net                 /etc/screenrc 屏幕设定                 &lt;/p&gt;

&lt;h2 id=&quot;section-28&quot;&gt;网络&lt;/h2&gt;

&lt;p&gt;/etc/iftab 网卡MAC地址绑定              /etc/hosts 主机列表             /etc/hostname 主机名&lt;/p&gt;

&lt;p&gt;/etc/resolv.conf 域名解析服务器地址             /etc/network/interfaces 网卡配置文件&lt;/p&gt;

&lt;h2 id=&quot;section-29&quot;&gt;用户配置文件&lt;/h2&gt;

&lt;p&gt;/etc/ 目录下的文件，只有root用户才有权修改。应用软件的全局配置文件，通常普通用户也不能够修改，如果要通过配置软件，来适应特殊需求，您可以修改用户配置文件。&lt;/p&gt;

&lt;p&gt;用户配置文件通常为全局配置文件的同名隐藏文件，放在$HOME目录下，例如：&lt;/p&gt;

&lt;p&gt;/etc/inputrc /home/user/.inputrc&lt;/p&gt;

&lt;p&gt;/etc/vim/vimrc /home/user/.vim/vimrc&lt;/p&gt;

&lt;p&gt;也有少数例外，通常是系统程序&lt;/p&gt;

&lt;h1 id=&quot;section-30&quot;&gt;软件安装&lt;/h1&gt;
&lt;p&gt;## DPKG ##&lt;/p&gt;

&lt;p&gt;Linux系统中，软件通常以源代码或者预编译包的形式提供。&lt;/p&gt;

&lt;p&gt;软件源代码需要编译为二进制的机器代码才能够使用，安装比较耗时，不过您可以自行调节编译选项，决定需要的功能或组件，或者针对硬件平台作一些优化。&lt;/p&gt;

&lt;p&gt;预编译的软件包，通常是由软件的发布者进行编译，您只要将软件拷贝到系统中就可以了。考虑到预编译软件包的适用性，预编译软件包通常不会针对某种硬件平台优化。它所包含的功能和组件也是通用的组合。&lt;/p&gt;

&lt;p&gt;Ubuntu系统中，软件通常以 deb 格式的包文件发布，它是一种预编译软件包。deb包中除了包含已编译的软件，通常还包括软件的拷贝路径、对其它软件包的依赖关系纪录、比较通用的配置文件以及软件的描述、版本、作者、类别、占用空间等信息。&lt;/p&gt;

&lt;p&gt;deb软件包命令遵行如下约定：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;soft_ver-rev_arch.deb

soft软件包名称           ver软件版本号           revUbuntu修订版本号        arch目标架构名称
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如： azureus_2.4.0.2-0ubuntu2_all.deb&lt;/p&gt;

&lt;p&gt;您需要使用 dpkg 命令来管理deb软件包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dpkg -i | --install xxx.deb 安装deb软件包

dpkg -r | --remove xxx.deb 删除软件包

dpkg -r -P | --purge xxx.deb 连同配置文件一起删除

dpkg -I | -info xxx.deb 查看软件包信息

dpkg -L xxx.deb 查看包内文件

dpkg -l 查看系统中已安装软件包信息

dpkg-reconfigure xxx 重新配置软件包
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些时候，您使用 dpkg 安装一个软件包，系统会提示您该软件包依赖其它软件包。这时，您先安装其它软件包，直到满足依赖关系为止。或者同时安装多个软件包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dpkg -i aaa.deb bbb.deb ccc.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;apt&quot;&gt;APT&lt;/h2&gt;

&lt;p&gt;如果一个软件依赖关系过于复杂，使用 dpkg&lt;/p&gt;

&lt;p&gt;来安装它，并不是一个明智的选择，这个时候您就需要用到APT软件包管理系统。APT可以自动的检查依赖关系，通过您预设的方式来获得相关软件包，并自动&lt;/p&gt;

&lt;p&gt;安装配置它。事实上，在多数情况下，我们推荐您使用APT软件包管理系统。&lt;/p&gt;

&lt;p&gt;APT系统需要一个软件信息数据库和至少一个存放着大量deb包的软件仓库，我们称之为 源 。 源 可以是网络服务器，安装CD或者本地软件仓库。您需要修改 /etc/apt/sources.list 文件，使APT系统能够连接到 源。&lt;/p&gt;

&lt;p&gt;从以下页面中获得网络安装源的列表，并且根据您的网络环境，选择速度较快的源。&lt;/p&gt;

&lt;p&gt;http://wiki.ubuntu.org.cn/%E5%BF%AB%E9%80%9F%E……%97/DapperDrake&lt;/p&gt;

&lt;p&gt;APT系统主要包括 apt-get 和 apt-cache 等命令。通常是复合命令，包含若干个子命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install xxx 安装xxx

-d 仅下载           -f 强制安装

apt-get remove xxx 卸载xxx

apt-get update 更新软件信息数据库

apt-get upgrade 进行系统升级

apt-cache search 搜索软件包
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：建议您经常使用 sudo apt-get update 命令来更新您的软件信息数据库&lt;/p&gt;

&lt;h2 id=&quot;apt-1&quot;&gt;APT系统修复&lt;/h2&gt;

&lt;p&gt;由于各种意外，APT系统可能会出现问题，使用如下命令，尝试进行修复：apt-get -f install&lt;/p&gt;

&lt;h1 id=&quot;section-31&quot;&gt;源码包&lt;/h1&gt;

&lt;p&gt;对于绝大多数软件，我们建议您使用APT系统来安装它。在少数情况下，例如某软件没有以deb包的格式发布，或者需要定制适合自己的软件，您可以通过编译源代码的方式安装它。&lt;/p&gt;

&lt;p&gt;首先需要下载软件的源码包，并且将它解包为一些源代码文件。并了便于管理，建议将下载的源码包移动到 /usr/local/src/ 目录下，并在这里解包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mv xxx.tar.gz /usr/local/src 移动源码包

cd /usr/local/src 进入“/usr/local/src/”目录

sudo tar -xzvf xxx.tar.gz 解包源码

cd xxx_ver/ 进行解包后的源码目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源码目录中通常有一个 configure 脚本，用来配置即将开始的编译过程。您可以执行它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ./configure [--prefix=/usr/loca/xxx ......]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它会自动检测软件的编译环境和依赖关系，并且生成 Makefile 文件。&lt;/p&gt;

&lt;p&gt;使用带参数的命令 ./configure –help ，或者阅读 INSTALL 文件，查看该脚本允许的参数。例如使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--prefix=/usr/local/xxx 参数，将软件的安装目录设定为 /usr/local/xxx/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;。（如果一定要将软件安装在单独目录下，建议您安装在这里）&lt;/p&gt;

&lt;p&gt;现在执行 make 命令，系统会根据 Makefile 文件中的设定，通过 make 工具调用编译器和所需资源文件，将源代码编译成目标文件。&lt;/p&gt;

&lt;p&gt;sudo make&lt;/p&gt;

&lt;p&gt;执行 make install 命令， make 工具会自动连接目标文件和库文件，将最终生成的文件拷贝到 Makefile 文件设定的路径中，并且完成更改文件的属性，删除残留文件等活动。&lt;/p&gt;

&lt;p&gt;sudo make install&lt;/p&gt;

&lt;p&gt;现在，编译安装已经完成，为了更方便的使用它，需要给程序的可执行文件作一个符号链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ln -sf /usr/local/xxx/可执行文件 /usr/local/bin/可执行文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tip:为了顺利的进行编译，至少需要安装 build-essential 软件包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;xwindow&quot;&gt;Xwindow简介&lt;/h1&gt;
&lt;p&gt;Xwindow是工作站图形系统的工业标准，它有多种不同的实现，Ubuntu系统中使用的为Xorg。&lt;/p&gt;

&lt;p&gt;（比较前卫的图形界面系统XGL，实际代替X服务器的作用，另外还有与之配套的窗口管理器）&lt;/p&gt;

&lt;h2 id=&quot;section-32&quot;&gt;历史&lt;/h2&gt;

&lt;p&gt;当然，Xwindow有悠久的历史和传统，不过那不在我们讨论的范围。您要注意的有两点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Xwindow 和 Xbox 中的“X”本意是不同的， X 只是 W 后的一个字母，差不多应该这样理解，Xwindow 是 Window 的接班人 （注意，Window不是Windows）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样，也不要把 Xwindow 说成是 Xwindows，那是一种亵渎！一切伟大的创造，都应得到应有的理解和尊重。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-33&quot;&gt;架构及原理&lt;/h2&gt;

&lt;p&gt;Xwindow使用服务器－客户端架构。无论本地图形界面，还是远程图形界面，都以同样的流程工作。这样便不需要分别进行设计和维护，极大的提高了网络透明性。&lt;/p&gt;

&lt;p&gt;本地X客户端 ┐ ┌ 键盘&lt;/p&gt;

&lt;p&gt;远程X客户端 ┼ X协议 ─ X服务器 ─ 硬件规范 ┼ 鼠标&lt;/p&gt;

&lt;p&gt;远程X客户端 ┘ └ 显示器&lt;/p&gt;

&lt;h2 id=&quot;xserver&quot;&gt;Xserver&lt;/h2&gt;

&lt;p&gt;Xwindow系统服务器端，通过驱动程序（硬件规范）来管理硬件资源。&lt;/p&gt;

&lt;p&gt;例如：当我们移动鼠标时，通过驱动程序，向 Xserver 发送信息：&lt;/p&gt;

&lt;p&gt;“向右移动200点，向上移动100点”（向右上移动）；“按下左键”……&lt;/p&gt;

&lt;p&gt;Xserver作出如下响应：&lt;/p&gt;

&lt;p&gt;1、上一次鼠标停止的坐标为600,500&lt;/p&gt;

&lt;p&gt;2、向右200，向上100。现在鼠标位于坐标800,600&lt;/p&gt;

&lt;p&gt;3、坐标800,600处，为窗口Firefox的“关闭”按钮&lt;/p&gt;

&lt;p&gt;4、根据预设动作，将 “点击Firefox窗口的关闭按钮” 翻译为 “关闭窗口Firefox”&lt;/p&gt;

&lt;p&gt;5、向X客户端Firefox发送一个“退出”消息&lt;/p&gt;

&lt;p&gt;6、Xserver通过显示子系统（显卡、显示器），全程显示鼠标的位置和移动&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;事实上，向程序发送“退出”信号，通常窗口管理器完成……为了描述方便，这里暂不区分。稍后，我们将向您介绍 窗口管理器 的其它一些细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大多数的鼠标不需要专门的驱动程序，因为它们符合某一硬件规范，例如：有四个移动方向和三个键&lt;/p&gt;

&lt;h2 id=&quot;xclient&quot;&gt;Xclient&lt;/h2&gt;

&lt;p&gt;Xwindow系统客户端，通过X协议，实现与Xserver 的交互。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;1、Xclient （假设Firefox） 接收Xserver的消息： 输入焦点在地址栏的范围内，“ubuntu.org.cn”，回车&lt;/p&gt;

&lt;p&gt;2、Firefox根据预设动作，将这些消息识别为 “打开链接 ubuntu.org.cn”&lt;/p&gt;

&lt;p&gt;3、Firefox向域名服务器请求 链接 “ubuntu.org.cn”。域名服务器将这个请求转换为 “http://ubuntu.org.cn/” 和 IP地址211.148.131.7，发送回 Firefox&lt;/p&gt;

&lt;p&gt;4、Firefox将 “http://ubuntu.org.cn/”显示在地址栏（向Xserver发送请求，在地址栏位置显示这个地址）&lt;/p&gt;

&lt;p&gt;5、Firefox向地址 211.148.131.7 请示显示页面。&lt;/p&gt;

&lt;p&gt;6、Firefox将服务器发送回的页面显示在主窗口中&lt;/p&gt;

&lt;h2 id=&quot;xprotocol&quot;&gt;Xprotocol&lt;/h2&gt;

&lt;p&gt;Xwindow系统协议，Xserver和Xclient之间进行通信的规则&lt;/p&gt;

&lt;h2 id=&quot;section-34&quot;&gt;窗口管理器&lt;/h2&gt;

&lt;p&gt;Window Manager，一种特殊的Xclient。&lt;/p&gt;

&lt;p&gt;使用窗口管理器时，Xserver并不直接与其它Xclient通信，而是通过WM中转，当一些消息被定义为WM指令时，它们会被拦截。例如Alt+F4关闭窗口、拖动标题栏……&lt;/p&gt;

&lt;p&gt;消息“打开链接 ubuntu.org.cn”，具体内容如下：&lt;/p&gt;

&lt;p&gt;输入焦点在地址栏的范围内，“ubuntu.org.cn”，回车&lt;/p&gt;

&lt;p&gt;Xserver并不能直接判断焦点，而是这样：&lt;/p&gt;

&lt;p&gt;1、Xserver向WM发送位置和点击的信息，WM根据当前的“焦点策略”确定激活（最上层）的窗口为Firefox&lt;/p&gt;

&lt;p&gt;2、Xserver将Firefox显示在最上层，高亮显示它的标题栏&lt;/p&gt;

&lt;p&gt;3、在窗口Firefox内点击地址栏，或者 Ctrl+L，Xserver将位置信息发送给WM，WM再发送给Firefox&lt;/p&gt;

&lt;p&gt;4、Firefox判断当前焦点后，显示一个闪动的文字输入光标&lt;/p&gt;

&lt;p&gt;5、Firefox将输入光标通过WM发送给Xserver，Xserver在屏幕相应位置进行显示&lt;/p&gt;

&lt;p&gt;那么，“窗口管理器”到底能作些什么呢？其实它所作的一切都是管理窗口。例如：&lt;/p&gt;

&lt;p&gt;1.最上层的窗口会把其它窗口挡住&lt;/p&gt;

&lt;p&gt;2.它通常是一个“已激活窗口”，根据不同的“焦点策略”，窗口管理器确定被激活的窗口。&lt;/p&gt;

&lt;p&gt;激活窗口标题栏高亮显示，接收大部分的键盘消息和窗口内的鼠标点击消息。&lt;/p&gt;

&lt;p&gt;3.为了美观和容易分辨，大多数窗口都要有标题栏和边框。&lt;/p&gt;

&lt;p&gt;为了方便，标题栏上还要有一些按钮，比如：最小化，最大化，关闭（这些按钮是窗口管理器请求的小窗口）&lt;/p&gt;

&lt;p&gt;4.一个窗口可以在另一个窗口旁边显示，而不一定完全被遮挡。为了实现这一点，就要控制窗口显示的位置&lt;/p&gt;

&lt;p&gt;5.为了控制窗口的显示位置，需要将整个屏幕用座标描述，最好的办法是绘制一个填充整个屏幕的窗口，也就是根窗口。&lt;/p&gt;

&lt;p&gt;6.因为根窗口是最大的，所以它可以严严实实的遮挡任何窗口，为了避免这一点，根窗口永远在最底层。&lt;/p&gt;

&lt;p&gt;这很形象的说明了为什么它叫作“根窗口” ……root&lt;/p&gt;

&lt;p&gt;7.根窗口不一定只有一个，大多数的窗口管理器可以使用 “工作区” ，来切换显示多个根窗口&lt;/p&gt;

&lt;p&gt;8.根窗口固定位置上通常放置一些其它Xclient的窗口，例如底部面板，顶部面板，侧面板，程序启动图标&lt;/p&gt;

&lt;p&gt;9.面板上又可以放一些其它的Xclient窗口，如任务条，启动栏，菜单……&lt;/p&gt;

&lt;p&gt;任务条可以以图标显示正在运行的任务，还可以作其它的杂活，像自动挂载USB设备……&lt;/p&gt;

&lt;h2 id=&quot;section-35&quot;&gt;启动流程&lt;/h2&gt;

&lt;p&gt;我们知道 init 是linux的根进程，是所有进程的父进程。同样， xinit是所有Xwindow进程的根进程&lt;/p&gt;

&lt;p&gt;Startx&lt;/p&gt;

&lt;p&gt;startx 命令可以在命令行下启动图形界面。执行startx 命令时，实际执行这一命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据脚本 /etc/X11/xinit/xserverrc 启动Xserver，同时根据脚本 /etc/X11/xinit/xinitrc 启动指定Xclient进程，例如窗口管理器&lt;/p&gt;

&lt;p&gt;脚本 /etc/X11/xinit/xserverrc 以预设的参数运行程序 /usr/bin/X11/X&lt;/p&gt;

&lt;p&gt;/etc/X11/xinit/xinitrc 脚本则指向 /etc/X11/Xsession ，依次启动 /etc/X11/Xsession.d 目录中的脚本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;您可以在用户配置文件 ~/.Xsession 中定义使用的WM，它的优先级高于全局配置文件(对于GDM会话不起作用)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;startx启动时，并不会再进行身份认证。因为它启动的是 /etc/X11/Xsession.d/gnome-session ，而不是 GDM会话&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gdm&quot;&gt;GDM会话&lt;/h2&gt;

&lt;p&gt;Ubuntu系统启动时自动进入图形界面，不需要运行 startx 命令&lt;/p&gt;

&lt;p&gt;在某些启动级别中，包含了gdm的启动脚本，例如 ： /etc/rc2.d/S13gdm&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;指向 /etc/gdm/gdm-cdd.conf 文件，加载预设视觉主题，启动 /usr/lib/gdm/gdmgreeter（登录屏幕）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户身份认证完成后，启动 /etc/X11/default-display-manager 这个文件中设定的默认窗口管理器 /usr/sbin/gdm&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;gdm在启动时，会要求用户名和密码，也就是我们看到的登录屏幕（gdmgreeter）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;/usr/share/xsessions 目录下为所有可用登录会话的脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置文件&lt;/p&gt;

&lt;h2 id=&quot;x&quot;&gt;X服务器&lt;/h2&gt;

&lt;p&gt;X服务器的主要配置文件为 /etc/X11/xorg.conf&lt;/p&gt;

&lt;h2 id=&quot;section-36&quot;&gt;布局&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Section &quot;ServerLayout&quot;

Identifier &quot;Default Layout&quot;

Screen &quot;Default Screen&quot; 0 0

InputDevice &quot;Generic Keyboard&quot;

InputDevice &quot;Configured Mouse&quot;

EndSection
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;定义了 布局标识 、 屏幕标识 、 键盘标识 、 鼠标标识&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-37&quot;&gt;模块&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Section &quot;Module&quot;

Load &quot;i2c&quot;

Load &quot;bitmap&quot;

Load &quot;ddc&quot;

Load &quot;dri&quot;

Load &quot;extmod&quot;

Load &quot;freetype&quot;

Load &quot;glx&quot;

Load &quot;int10&quot;

Load &quot;type1&quot;

Load &quot;vbe&quot;

EndSection
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x-1&quot;&gt;X核心字体路径&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Section &quot;Files&quot;

FontPath &quot;/usr/share/X11/fonts/75dpi&quot;

FontPath &quot;/usr/share/X11/fonts/100dpi&quot;

FontPath &quot;/usr/share/X11/fonts/misc&quot;

FontPath &quot;/usr/share/X11/fonts/cyrillic&quot;

FontPath &quot;/usr/share/X11/fonts/100dpi/:unscaled&quot;

FontPath &quot;/usr/share/X11/fonts/75dpi/:unscaled&quot;

FontPath &quot;/usr/share/X11/fonts/Type1&quot;

FontPath &quot;/usr/share/fonts/Chinese/wqy-bitmapfont&quot;

EndSection
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-38&quot;&gt;屏幕&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Section &quot;Screen&quot;

Identifier &quot;Default Screen&quot;

Device &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;

Monitor &quot;DELL E176FP&quot;

DefaultDepth 24

SubSection &quot;Display&quot;

Depth 1

Modes &quot;1280x1024&quot; &quot;1152x864&quot; &quot;1024x768&quot; &quot;800x600&quot; &quot;720x400&quot; &quot;640x480&quot;

………………

EndSubSection

EndSection

* DefaultDepth 24 默认色深

* SubSection 可用色深及分辨率
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-39&quot;&gt;显卡&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Section &quot;Device&quot;

Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;

Driver &quot;fglrx&quot;

Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;

VideoRam 131072

EndSection

* Identifier 显卡标识

* Driver 显卡驱动（如不同正常启用图形界面，首先尝试&quot;vesa&quot;）

* Option 显卡参数

* VideoRam 显存大小
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-40&quot;&gt;显示器&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Section &quot;Device&quot;

Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;

Driver &quot;fglrx&quot;

Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;

VideoRam 131072

EndSection
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-41&quot;&gt;配置文件内部结构&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/

├/ &quot;ServerLayout&quot; 布局

│├ &quot;InputDevice&quot; keyboard 键盘

│├ &quot;InputDevice&quot; mouse 鼠标

││

│└/ &quot;Screen&quot; 显示子系统

│ ├ &quot;Monitor&quot; 显示器

│ ├ &quot;Device&quot; videocard 显卡

│

│

├ &quot;Files&quot; 字体

└ &quot;Module&quot; 模块
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;x-2&quot;&gt;X客户端&lt;/h2&gt;

&lt;p&gt;在 /etc/X11/Xsession 文件中可以发现下列内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OPTIONFILE=/etc/X11/Xsession.options

SYSRESOURCES=/etc/X11/Xresources

USRRESOURCES=$HOME/.Xresources

SYSSESSIONDIR=/etc/X11/Xsession.d

USERXSESSION=$HOME/.xsession

ALTUSERXSESSION=$HOME/.Xsession

ERRFILE=$HOME/.xsession-errors

* OPTIONFILE=/etc/X11/Xsession.options 设定X进程的启动参数。例如允许用户进程allow-user-xsession

* Xresources X资源文件。许多程序保留了X接口，允许X服务器管理一些视觉选项，例如窗口内的字体，配色等

* xsession X进程。可以设置一些启动时自动运行的程序，也可以用来设定自己的窗口管理器（窗口管理器和桌面环境或者登录管理器是无关的）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-42&quot;&gt;字体&lt;/h2&gt;

&lt;p&gt;freetype渲染引擎&lt;/p&gt;

&lt;p&gt;作为Xorg服务器的一个模块，freetype的功能包括读取Truetype字体信息，如大小、分辨率、编码等，并以之为依据渲染字体 -&lt;/p&gt;

&lt;p&gt;freetype2.x相对于freetype1.x 增加了抗锯齿等功能 - ( /etc/X11/xorg/conf 的 Module&lt;/p&gt;

&lt;p&gt;字段中，可以选择字体渲染模块，建议使用默认的 freetype )&lt;/p&gt;

&lt;p&gt;freetype只负责渲染字体。而查找字体，则可以由X服务器、X客户端或者字体服务器来完成。找到字体后，使用freetype引擎就地渲染&lt;/p&gt;

&lt;p&gt;X核心字体&lt;/p&gt;

&lt;p&gt;X服务器根据X客户端的请求（字符编码），查找字体并进行渲染，然后显示，我们称之为&lt;/p&gt;

&lt;p&gt;Xft字体&lt;/p&gt;

&lt;p&gt;X客户端自行查找字体并进行渲染，X服务器只负责显示&lt;/p&gt;

&lt;p&gt;由于Xft字体的渲染在客户端完成，所以它可以动态的加载，而不需要随同X服务器一同启动&lt;/p&gt;

&lt;p&gt;字体服务器&lt;/p&gt;

&lt;p&gt;另外还有一种字体服务器模式，例如 XFT字体：当客户端请求字体时，X服务器将请求转发到字体服务器，由字体服务器查找字体，并使用freetype引擎渲染，将结果传回X服务器，X服务器进行显示……&lt;/p&gt;

&lt;p&gt;X核心字体&lt;/p&gt;

&lt;p&gt;/etc/X11/xorg.conf 中可以配置X核心字体的搜索路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Section &quot;Files&quot;

FontPath &quot;/usr/X11R6/lib/X11/fonts/misc/&quot;

FontPath &quot;/usr/X11R6/lib/X11/fonts/Type1/&quot;

FontPath &quot;/usr/X11R6/lib/X11/fonts/Speedo/&quot;

FontPath &quot;/usr/X11R6/lib/X11/fonts/100dpi/&quot;

FontPath &quot;/usr/X11R6/lib/X11/fonts/75dpi/&quot;

EndSection

*

当X客户端向X服务器请求显示文字的时候，X服务器会按上面列表的先后顺序查找字体

例如显示中文时，如果第一个路径中的字体不包含中文，则查找下面的路径，直到发现中文字体

*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请将您偏好的字体放在靠前的位置&lt;/p&gt;

&lt;p&gt;要使安装的字体能够作为X核心字体使用，将字体的安装路径添加到上面的列表中，使用 mkfontscale 、 mkfontdir&lt;/p&gt;

&lt;p&gt;扫瞄文件夹中的字体，并生成索引，就可以了（建议使用 ttmkfdir 生成 fonts.scale ，将其复制为 fonts.dir ）&lt;/p&gt;

&lt;p&gt;字体的选择及显示风格，可以修改GTK1的配置文件，或者在Xresources文件中对程序单独进行定义&lt;/p&gt;

&lt;p&gt;事实上，在我们的日常应用中，X核心字体环境并不常见，使用GTK1图形库的程序、某些类型的终端……&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Emacs也是这样一个老派的程序……不过Emacs23中刚刚加入了xft字体的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;XFT字体&lt;/p&gt;

&lt;p&gt;Xft字体相关选项在 /etc/fonts/fonts.conf 文件中配置&lt;/p&gt;

&lt;p&gt;可以使用 fc-cache 命令，递归扫瞄以下目录中的字体（包括子文件夹中的字体），建立字体缓存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/share/X11/fonts

/usr/share/fonts

/usr/local/share/fonts

~/.fonts
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/fonts/fonts.conf 文件的 &lt;dir&gt; 字段&lt;/dir&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;多数支持GTK2或者Qt图形库的X客户端能够使用Xft字体渲染技术&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GTK2为Gnome使用的图形库，Qt为KDE使用的图形库。相对来说，GTK2图形库在程序的GUI设计中更加通用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装字体，只要将字体拷贝到以上任意目录， fc-cache -fv 刷新字体缓存即可 （参数: -f 强制刷新; -v 显示过程）&lt;/p&gt;

&lt;p&gt;使用命令 fc-list 列出所有可用字体&lt;/p&gt;

&lt;p&gt;字体的选择及显示风格，可以修改GTK2或者Qt的配置文件，建议使用图形界面配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一般情况下，桌面环境中附带了相关程序，例如 gnome-font-properties&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-43&quot;&gt;系统管理&lt;/h1&gt;

&lt;h2 id=&quot;section-44&quot;&gt;一些细节&lt;/h2&gt;

&lt;p&gt;Linux是大小写敏感的系统，所有的命令、路径、参数、变量……都区分大小写&lt;/p&gt;

&lt;p&gt;使用 TAB 键补全命令，无论任何时候，多按几次TAB总会有所帮助&lt;/p&gt;

&lt;p&gt;Shell的功能键能够协助您更高效的编辑命令，请熟悉其键绑定，尽量使用它&lt;/p&gt;

&lt;p&gt;命令由 命令名 、 分隔符 、 参数 、 操作对象 构成&lt;/p&gt;

&lt;p&gt;命令名&lt;/p&gt;

&lt;p&gt;标识命令的功能，例如cp(copy)、mv(move)、rm(remove)……&lt;/p&gt;

&lt;p&gt;有些命令包含一些子命令，您可以认为它的命令名由两个单词构成，例如“apt”软件包管理系统：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install 安装一个软件

apt-get remove 删除一个软件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分隔符&lt;/p&gt;

&lt;p&gt;通常为空格，多个连续的空格视为一个空格，下面两个命令相同：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp  a  b

cp  a  b
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;有一些特殊符号也属于分隔符，例如管道&lt;/td&gt;
      &lt;td&gt;、重定向 &amp;gt; 、 » 、 &amp;lt; 、后台运行 &amp;amp; 、序列执行 &amp;amp;&amp;amp; 、 ; 。使用这些符号时，您不需要再使用空格作为分隔符，例如：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;ls -al|less
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写为以下形式，是为了让您更容易的阅读它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -al | less
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数&lt;/p&gt;

&lt;p&gt;精细调节命令的行为，以 - 引导，通常为参数名的首字母。许多软件都可以使用 -h 参数来阅读使用说明，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用参数的全名，一般以 – 引导，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get --help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多数命令中，使用 - 引导多个字符，将会被视为多个参数，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get -help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;系统会解读为以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get -h -e -l -p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;少数命令的参数，不需要以 - 引导，或者使用 - 引导参数全名，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps aux

/etc/init.d/gdm start

mplayer -loop xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要对多个对象进行操作时，可以使用空格分隔符将它们隔开：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch 1 2 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用空格分隔的多个对象，视为一个整体，作为命令的一个操作对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mv 1 2 3 4 5 6 /home/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令把“1 2 3 4 5 6”作为一个操作对象，移动到另一个操作对象，“/home/”目录&lt;/p&gt;

&lt;p&gt;递归 表示在子层次中重复相同操作。例如递归复制某目录，不但复制当前目录及其下的所有文件；而且对当前目录的子目录，也进行递归复制的操作。&lt;/p&gt;

&lt;p&gt;格式约定&lt;/p&gt;

&lt;p&gt;使用 [] 表示可选项，实际输入为方括号中的内容，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls [-al]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ls是必须的，参数不需要以方括号括起来。&lt;/p&gt;

&lt;p&gt;使用 &amp;lt;&amp;gt; 表示必需项，实际输入为尖括号中的内容&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;使用&lt;/td&gt;
      &lt;td&gt;表示 或 ，以&lt;/td&gt;
      &lt;td&gt;分隔的项目不能同时使用，例如&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;tar [-z|j c|x vf] &amp;lt;归档文件&amp;gt; [源文件]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数通常紧跟命令名，除非必要，在命令格式中，我们通常省略它们&lt;/p&gt;

&lt;p&gt;系统信息
uptime  &lt;/p&gt;

&lt;p&gt;联机信息-时间，显示如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11:27pm up 9 days, 7:12, 3 user, load average: 0.07, 0.12, 0.14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前系统时间 系统运行时间 当前在线用户数 系统负荷 1分钟前 5分钟前 15分钟前&lt;/p&gt;

&lt;p&gt;w&lt;/p&gt;

&lt;p&gt;联机信息-已登录用户，显示如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;01:04:10 up 1:34, 2 users, load average: 0.25, 0.16, 0.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;uptime 信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT

user tty1 192.168.0.1 23:30 1:33 0.14s 0.12s -bash

用户名 登录方式 来源地址 登录时间 发呆时间 资源占用 当前任务

Tip：w [用户名称] : 显示某一用户相关信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;who&lt;/p&gt;

&lt;p&gt;联机信息，常用参数&lt;/p&gt;

&lt;p&gt;-r 运行级别&lt;/p&gt;

&lt;p&gt;whoami&lt;/p&gt;

&lt;p&gt;显示当前用户名&lt;/p&gt;

&lt;p&gt;last&lt;/p&gt;

&lt;p&gt;最近用户登录信息&lt;/p&gt;

&lt;p&gt;-&lt;数字&gt; 使用数字作为参数，控制显示条目。例如&lt;/数字&gt;&lt;/p&gt;

&lt;p&gt;last -10 显示10条纪录&lt;/p&gt;

&lt;p&gt;uname&lt;/p&gt;

&lt;p&gt;系统信息&lt;/p&gt;

&lt;p&gt;-s 内核名称（默认参数）           -a 全部               -p CPU信息                -n 主机名          &lt;/p&gt;

&lt;p&gt;-r 内核发行信息（版本号）                -v 内核版本信息&lt;/p&gt;

&lt;p&gt;date&lt;/p&gt;

&lt;p&gt;显示、设定系统时间&lt;/p&gt;

&lt;p&gt;-u 显示格林尼洛时间（UTC）&lt;/p&gt;

&lt;p&gt;MMDDhhmm[[CC]YY][.ss] 设定时间，需要管理员权限。例如： date 12292359&lt;/p&gt;

&lt;p&gt;MM 月份 DD 天数 hh 小时 mm 分钟 CC 年份前两位 YY 年份后两位 ss 秒钟&lt;/p&gt;

&lt;p&gt;秒钟、年份为可选，例如： date 122923592006.59&lt;/p&gt;

&lt;p&gt;+[%X]设定显示格式，以下为date默认输出格式：&lt;/p&gt;

&lt;p&gt;date +%Y年%m月%d日%A%H:%M:%S%Z&lt;/p&gt;

&lt;p&gt;格式控制            %n 换行             %t 制表符&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;小时                    %H(00~23) %I(01~12) %k(0~23) %l(1~12) %p(AM&lt;/td&gt;
      &lt;td&gt;PM)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;分、秒                %M分钟(00~59)                  %S秒(00..61)              %T(hh:mm:ss) %r(hh:mm:ss [AM&lt;/td&gt;
      &lt;td&gt;PM])&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;%s 从1970年1月1日00:00:00 UTC到目前为止的秒数              %X(%H:%M:%S)                 %Z时区&lt;/p&gt;

&lt;p&gt;星期                    %a(Sun~Sat) %A(Sunday~Saturday) %w : 一周中的第几天 (0..6)&lt;/p&gt;

&lt;p&gt;年份                    %Y(0000~9999) %y(00~99)&lt;/p&gt;

&lt;p&gt;月份                    %m(01~12) %b %h(Jan~Dec) %B(January~December)&lt;/p&gt;

&lt;p&gt;日期                    %d(01~31) %j(001~366)&lt;/p&gt;

&lt;p&gt;%x(本地格式mm/dd/yy) %D(mm/dd/yy) %c&lt;/p&gt;

&lt;p&gt;一年中的第几周&lt;/p&gt;

&lt;p&gt;%U(00~53)以Sunday为一周的第一天 %W(00~53)以Monday为一周的第一天&lt;/p&gt;

&lt;p&gt;cal&lt;/p&gt;

&lt;p&gt;显示日历&lt;/p&gt;

&lt;p&gt;文件管理
一些细节&lt;/p&gt;

&lt;p&gt;/ 目录为文件系统根目录，所有目录都是它的子目录&lt;/p&gt;

&lt;p&gt;绝对路径以 / 起始，相对路径以当前所在目录起始&lt;/p&gt;

&lt;p&gt;目录是一种特殊类型的文件，如果没有特别指明， 文件 包括文件和目录&lt;/p&gt;

&lt;p&gt;.. 表示上一级目录， . 表示当前目录，它们是两个特殊目录&lt;/p&gt;

&lt;p&gt;链接&lt;/p&gt;

&lt;p&gt;为当前文件建立在其它路径中的访问方法。例如将系统中其它位置的可执行文件，链接到 /usr/local/bin 目录下，使用命令调用。&lt;/p&gt;

&lt;p&gt;ls [路径]&lt;/p&gt;

&lt;p&gt;显示当前目录文件列表&lt;/p&gt;

&lt;p&gt;–color 不同属性以不同颜色显示（默认参数）&lt;/p&gt;

&lt;p&gt;-a 全部显示                -i 显示inode值          -l 详细信息                &lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-F 显示文件类型后缀 目录/ 链接@ 可执行文件* 端口文件= 管道文件&lt;/td&gt;
      &lt;td&gt;&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;-A 显示隐藏文件                 -R 递归显示子目录文件列表                -S 按文件大小排序            &lt;/p&gt;

&lt;p&gt;-t 按修改时间排序              -u 按访问时间排序             -d 只显示目录，不递归显示目录下的文件&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;cd [目录路径]&lt;/td&gt;
      &lt;td&gt;[特殊路径]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;切换目录&lt;/p&gt;

&lt;p&gt;目录路径可以使用绝对路径或者相对路径特殊路径：&lt;/p&gt;

&lt;p&gt;~ $HOME目录（默认值）          - 上一次目录              .. 上一级目录             . 当前目录&lt;/p&gt;

&lt;p&gt;说明：您可以通过修改 /etc/environment 文件，来定义 $CDPATH 变量，设定“cd”命令的搜索路径。&lt;/p&gt;

&lt;p&gt;pwd&lt;/p&gt;

&lt;p&gt;显示当前路径&lt;/p&gt;

&lt;p&gt;file &lt;文件名&gt;&lt;/文件名&gt;&lt;/p&gt;

&lt;p&gt;显示文件类型&lt;/p&gt;

&lt;p&gt;-i 显示mime类型&lt;/p&gt;

&lt;p&gt;du [路径]&lt;/p&gt;

&lt;p&gt;计算文件或目录空间占用&lt;/p&gt;

&lt;p&gt;-h 人性化显示。自动以G、M、K为单位显示占用空间大小                 -l 重复计算硬链接文件大小&lt;/p&gt;

&lt;p&gt;-L 计算符号链接文件大小          -a 显示当前目录子目录中的文件                 -c 显示文件数&lt;/p&gt;

&lt;p&gt;less &lt;文件名&gt;&lt;/文件名&gt;&lt;/p&gt;

&lt;p&gt;浏览文件，使用VI和Emacs两种风格的键绑定。以下为VI风格键绑定&lt;/p&gt;

&lt;p&gt;Ctrl+f(orward) 向下翻一页 Ctrl+d(own) 向下翻半页&lt;/p&gt;

&lt;p&gt;Ctrl+b(ackward) 向上翻一页 Ctrl+u(p) 向上翻半页             / 查找 q(uit) 退出&lt;/p&gt;

&lt;p&gt;touch &lt;目标文件&gt;&lt;/目标文件&gt;&lt;/p&gt;

&lt;p&gt;触碰，在不修改文件的前提下，更改其时间属性。通常用来创建一个空文件&lt;/p&gt;

&lt;p&gt;mkdir &lt;文件夹&gt;&lt;/文件夹&gt;&lt;/p&gt;

&lt;p&gt;创建文件夹&lt;/p&gt;

&lt;p&gt;-p &lt;多级目录&gt; 按路径创建多级目录           -m &lt;数字权限值&gt; 设定权限&lt;/数字权限值&gt;&lt;/多级目录&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;cp &lt;源文件&gt; &amp;lt;目标目录&lt;/源文件&gt;&lt;/td&gt;
      &lt;td&gt;文件&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;将源文件复制为目录文件，或者将源文件复制到目标目录。多个源文件使用空格分隔&lt;/p&gt;

&lt;p&gt;cp &lt;源目录&gt; &lt;目标目录&gt;&lt;/目标目录&gt;&lt;/源目录&gt;&lt;/p&gt;

&lt;p&gt;将源目录复制到目标目录中，如果复制多个源目录，需要使用 -R 参数&lt;/p&gt;

&lt;p&gt;-a 相当于-dpr参数             -d 保留链接                -f 强制复制，覆盖目标文件                 -i 覆盖时询问用户&lt;/p&gt;

&lt;p&gt;-p 保留修改时间和访问权限                -r -R 递归复制（目录=&amp;gt;目录）          -l 创建链接                &lt;/p&gt;

&lt;p&gt;-v 显示过程&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;rm &amp;lt;目标目录&lt;/td&gt;
      &lt;td&gt;文件&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;删除&lt;/p&gt;

&lt;p&gt;-r -R 递归删除            -f 强制删除（无需确认，直接删除。慎用！）               -i 交互式删除（询问用户）&lt;/p&gt;

&lt;p&gt;rmdir &lt;目标目录&gt;&lt;/目标目录&gt;&lt;/p&gt;

&lt;p&gt;删除目录时，建议您使用“rm -r”命令&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;mv &lt;源文件&gt; &amp;lt;目标目录&lt;/源文件&gt;&lt;/td&gt;
      &lt;td&gt;文件&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;相当于cp后删除源文件，也可以作为“重命名”使用。&lt;/p&gt;

&lt;p&gt;mv &lt;源目录&gt; &lt;目标目录&gt;&lt;/目标目录&gt;&lt;/源目录&gt;&lt;/p&gt;

&lt;p&gt;-r -R 递归&lt;/p&gt;

&lt;p&gt;ln &lt;源文件&gt; &lt;链接&gt;&lt;/链接&gt;&lt;/源文件&gt;&lt;/p&gt;

&lt;p&gt;链接&lt;/p&gt;

&lt;p&gt;-s 符号链接                -f 强制链接，覆盖目标文件                 -i 覆盖前询问用户&lt;/p&gt;

&lt;p&gt;文件操作
nano&lt;/p&gt;

&lt;p&gt;一个简单轻便的文本编辑器，使用Emacs风格的键绑定。&lt;/p&gt;

&lt;p&gt;split &lt;源文件&gt; [目标文件名前缀]&lt;/源文件&gt;&lt;/p&gt;

&lt;p&gt;将源文件按一定规则分割成若干个目标文件。默认文件名前缀为 x&lt;/p&gt;

&lt;p&gt;-&lt;行数&gt; 按行数分割文件           -l &lt;行数&gt; 同上&lt;/行数&gt;&lt;/行数&gt;&lt;/p&gt;

&lt;p&gt;-b &lt;字节&gt; 按大小分割文件。可以使用b、k、m作单位，不指定单位的情况下，默认单位为b&lt;/字节&gt;&lt;/p&gt;

&lt;p&gt;-C &lt;字节&gt; 按大小分割文件，并尽量保持每行的完整&lt;/字节&gt;&lt;/p&gt;

&lt;p&gt;示例：split -C 100k file.split x&lt;/p&gt;

&lt;p&gt;cat &lt;文件名&gt;&lt;/文件名&gt;&lt;/p&gt;

&lt;p&gt;输出文件内容。用空格分隔多个文件名，可以将多个文件内容连接到一起输出。使用重定向合并为一个文件&lt;/p&gt;

&lt;p&gt;-n 在输出中添加行号                   -b 在输出中添加行号，空行不编号            &lt;/p&gt;

&lt;p&gt;-s 将两行或以上的空行，合并为一个空行&lt;/p&gt;

&lt;p&gt;示例：cat xaa xab xac &amp;gt; file.split&lt;/p&gt;

&lt;p&gt;sort [-o &lt;输出文件&gt;] [-t &lt;分隔字符&gt;] [+&lt;起始字段&gt; - &lt;结束字段&gt;] [文件]&lt;/结束字段&gt;&lt;/起始字段&gt;&lt;/分隔字符&gt;&lt;/输出文件&gt;&lt;/p&gt;

&lt;p&gt;对文本内容排序&lt;/p&gt;

&lt;p&gt;-m 合并文件               -c 检查文件是否已按规则排序            -b 忽略行首空格字符                  &lt;/p&gt;

&lt;p&gt;-u 忽略内容重复行             -f 忽略大小写             -l 忽略非打印字符              -M 作为月份比较&lt;/p&gt;

&lt;p&gt;-d 按字典顺序排序，按照字母、数字、空格、制表符排序           -r 逆序输出&lt;/p&gt;

&lt;p&gt;more&lt;/p&gt;

&lt;p&gt;查看文件内容，我们建议您使用 less&lt;/p&gt;

&lt;p&gt;diff &lt;文件名&gt;&lt;/文件名&gt;&lt;/p&gt;

&lt;p&gt;比较文件&lt;/p&gt;

&lt;p&gt;cksum [文件名]&lt;/p&gt;

&lt;p&gt;计算文件的CRC值。不指定文件名则从标准输入设备读入数据，例如：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;echo xxx&lt;/td&gt;
      &lt;td&gt;cksum&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;md5sum [文件名] 计算文件的md5值。同上&lt;/p&gt;

&lt;p&gt;权限管理
一些细节&lt;/p&gt;

&lt;p&gt;一个文件主要包含下列属性， ls -l&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;rwx rwx rwx user group date filename&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;111 101 101&lt;/p&gt;

&lt;p&gt;其中，第一组为归属用户的权限，第二组为归属群组的权限，第三组为其它用户群组的权限。user为文件的归属用户，group为文件的归属群组，date为日期信息，filename为文件名。&lt;/p&gt;

&lt;p&gt;对于文件夹，必须拥有它的可执行权限，才能够使用 cd 命令进入该文件夹；拥有可读权限，才能够使用 ls 命令查看该文件夹的文件列表。&lt;/p&gt;

&lt;p&gt;root用户拥有最高权限。&lt;/p&gt;

&lt;p&gt;可以使用3位的二进制数字来描述一组权限，某一权限对应的数字为1,则表示具有该种权限，为0,则不具有该种权限。&lt;/p&gt;

&lt;p&gt;使用二进制数字来描述一组权限，虽然非常直观，但是3组权限需要用9位数来表示，使用不够方便。因此我们将三组权限使用3位8进制数字来表示。它们的对应关系为：&lt;/p&gt;

&lt;p&gt;r 100 4&lt;/p&gt;

&lt;p&gt;w 010 2&lt;/p&gt;

&lt;p&gt;x 001 1&lt;/p&gt;

&lt;p&gt;将这三位8进制数字相加的结果，就可以表示该组权限的具体内容，例如：&lt;/p&gt;

&lt;p&gt;7=4+2+1=rwx&lt;/p&gt;

&lt;p&gt;5=4+1=rx&lt;/p&gt;

&lt;p&gt;755=4+2+1 4+1 4+1=rwx r-x r-x&lt;/p&gt;

&lt;p&gt;还可以使用 a 、 u 、 g 、 o 表示归属关系，使用 = 、 + 、 - 表示权限变化，使用 r 、 w 、 x 表示权限内容，&lt;/p&gt;

&lt;p&gt;a 所有用户 u 归属用户 g 归属群组 o 其它用户&lt;/p&gt;

&lt;p&gt;= 具有权限 + 增加权限 - 去除权限&lt;/p&gt;

&lt;p&gt;r 可读权限 w 可写权限 x 可执行权限&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;a+x 给所有用户增加可执行权限&lt;/p&gt;

&lt;p&gt;go-wx 将归属群组和其它用户的可写、可执行权限去掉&lt;/p&gt;

&lt;p&gt;u=rwx 归属用户具有可读、可写、可执行权限&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;chmod &lt;权限表达式&gt; &amp;lt;文件&lt;/权限表达式&gt;&lt;/td&gt;
      &lt;td&gt;目录&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更改文件的权限。权限的表达式可以使用三位8进制数字表示，或者使用 augo +-= rxw-s 来表示&lt;/p&gt;

&lt;p&gt;-R 递归&lt;/p&gt;

&lt;p&gt;-v 显示过程&lt;/p&gt;

&lt;p&gt;-c 类似“-v”，仅显示更改部分&lt;/p&gt;

&lt;p&gt;–reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限&lt;/参考文件或目录&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;chmod -R a+x path&lt;/p&gt;

&lt;p&gt;chmod -Rv 755 path&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;chown &lt;归属用户&gt;[:归属群组] &amp;lt;文件&lt;/归属用户&gt;&lt;/td&gt;
      &lt;td&gt;目录&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更改文件的归属用户。可以使用用户名或者UID&lt;/p&gt;

&lt;p&gt;-R 递归              -v 显示过程                -c 类似 -v ，仅显示更改部分&lt;/p&gt;

&lt;p&gt;–reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限&lt;/参考文件或目录&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;chown user:admin path                   chown -R user.admin path              chown user path&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;chgrp &lt;归属群组&gt; &amp;lt;文件&lt;/归属群组&gt;&lt;/td&gt;
      &lt;td&gt;目录&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更改文件的归属群组。可以使用群组名或者GID&lt;/p&gt;

&lt;p&gt;参数同上&lt;/p&gt;

&lt;p&gt;SUID、SGID、Sticky bit&lt;/p&gt;

&lt;p&gt;某些情况下，需要以可执行文件归属用户的身份执行该文件，可以为该文件设置SUID。同样，设置SGID能够以该文件归属群组的身份执行它。&lt;/p&gt;

&lt;p&gt;例如：用户自行设定密码。出于安全方面的考虑， /etc/shadow 只能由root用户直接修改。&lt;/p&gt;

&lt;p&gt;-rw——- root root /etc/shadow&lt;/p&gt;

&lt;p&gt;这个时候，可以为程序 /usr/bin/passwd&lt;/p&gt;

&lt;p&gt;设置SUID，当普通用户执行“passwd”命令时，便能够以该程序归属用户root的身份修改 /etc/shadow&lt;/p&gt;

&lt;p&gt;文件。而“passwd”程序自身带有身份验证机制，不能通过验证时拒绝执行，从而保证了安全。&lt;/p&gt;

&lt;p&gt;ls -l /usr/bin/passwd&lt;/p&gt;

&lt;p&gt;-r-s–x–x root root /usr/bin/passwd&lt;/p&gt;

&lt;p&gt;我们发现，归属用户的可执行权限位使用 s ，表示SUID。同样，归属群组的可执行权限位使用 s ，表示SGID。任何用户或群组都拥有&lt;/p&gt;

&lt;p&gt;其它用户 的权限，所以不需要以 其它用户 身份执行文件，其它用户的可执行权限位便不会出现 s 。该权限位可能出现的属性为 t&lt;/p&gt;

&lt;p&gt;，也就是粘着位Sticky bit。&lt;/p&gt;

&lt;p&gt;ls -ld /tmp&lt;/p&gt;

&lt;p&gt;drwxrwxrwt root root /tmp&lt;/p&gt;

&lt;p&gt;粘着位表示任何用户都可能具有写权限，但只有该归属用户或root用户才能够删除&lt;/p&gt;

&lt;p&gt;SUID、SGID、Sticky bit也可以像权限一样，使用一个八进制数表示，如下：&lt;/p&gt;

&lt;p&gt;4 SUID&lt;/p&gt;

&lt;p&gt;2 SGID&lt;/p&gt;

&lt;p&gt;1 Sticky bit&lt;/p&gt;

&lt;p&gt;通过在“chmod”命令中使用4个八进制数的表达式，如 4755 ，用第一位表示SUID、SGID、或Sticky bit，便能够为文件设置这些特殊权限。示例：&lt;/p&gt;

&lt;p&gt;chmod -R 4755 path&lt;/p&gt;

&lt;p&gt;lsattr [路径]&lt;/p&gt;

&lt;p&gt;查看文件的特殊属性&lt;/p&gt;

&lt;p&gt;-a 全部显示                -d 只显示目录            -R 递归&lt;/p&gt;

&lt;p&gt;特殊属性包括：&lt;/p&gt;

&lt;p&gt;a：仅供附加用途                 b：不更新最后存取时间              c：压缩后存放            d：排除在倾倒操作之外&lt;/p&gt;

&lt;p&gt;i：不得任意更动文件或目录                s：保密性删除文件或目录          S：即时更新文件或目录&lt;/p&gt;

&lt;p&gt;u：预防以外删除&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;chattr +&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;=&lt;属性&gt; &lt;路径&gt;&lt;/路径&gt;&lt;/属性&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更改文件特殊属性&lt;/p&gt;

&lt;p&gt;-R 递归              -V 显示过程&lt;/p&gt;

&lt;p&gt;压缩解压
tar -c|x|u|r|t[z|j][v] -f &lt;归档文件&gt; [未打包文件]&lt;/归档文件&gt;&lt;/p&gt;

&lt;p&gt;将多个文件打包为一个归档文件，可以在打包的同时进行压缩。支持的格式为tar（归档）、gz（压缩）、bz2（压缩率更高，比较耗时）&lt;/p&gt;

&lt;p&gt;-c 创建               -x 解包               -u 更新               -r 添加               -t 查看               &lt;/p&gt;

&lt;p&gt;-d 比较压缩包内文件和文件                -A 将tar文件添加到归档文件中                  -z 使用gz压缩格式&lt;/p&gt;

&lt;p&gt;-j 使用bz2压缩格式           -v 显示过程                -f &lt;文件名&gt; 归档文件的文件名&lt;/文件名&gt;&lt;/p&gt;

&lt;p&gt;-C &lt;解压路径&gt; 将压缩包中的文件解压到指定目录             &lt;/解压路径&gt;&lt;/p&gt;

&lt;p&gt;[未打包文件] 创建、更新时必须填写&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;tar -zcvf xxx.tar.gz xxx/ xxx1 xxx2 xxx3 多个待打包文件以空格分隔&lt;/p&gt;

&lt;p&gt;tar -zcvf xxx.tar.gz /home/user/xxx/ 使用绝对路径打包，解包也使用绝对路径&lt;/p&gt;

&lt;p&gt;tar -zxvf xxx.tar.gz 按相对路径解包到当前目录下，或按绝对路径解包&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;tar -zcvf xxx.tar.gz xxx&lt;/td&gt;
      &lt;td&gt;split -b 1m 打包后，使用split分割为1m大小的多个文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其它参数&lt;/p&gt;

&lt;p&gt;-P 使用绝对路径压缩时，保留根目录“/”             -W 校验             -p 还原文件权限&lt;/p&gt;

&lt;p&gt;-w 询问用户               –totals 统计                -T &lt;表达式&gt; 处理符合条件的文件&lt;/表达式&gt;&lt;/p&gt;

&lt;p&gt;-X &lt;表达式&gt; 排除符合条件的文件&lt;/表达式&gt;&lt;/p&gt;

&lt;p&gt;zip [参数] &lt;压缩包&gt; &lt;源文件&gt;&lt;/源文件&gt;&lt;/压缩包&gt;&lt;/p&gt;

&lt;p&gt;使用zip格式打包文件&lt;/p&gt;

&lt;p&gt;-r 递归，将指定目录下的所有文件和子目录一并处理                   -S 包含系统和隐藏文件&lt;/p&gt;

&lt;p&gt;-y 直接保存符号连接，而非该连接所指向的文件                  -X 不保存额外的文件属性&lt;/p&gt;

&lt;p&gt;-m 将文件压缩并加入压缩文件后，删除源文件&lt;/p&gt;

&lt;p&gt;-&lt;压缩级别&gt; 1~9，数字越大，压缩率越高&lt;/压缩级别&gt;&lt;/p&gt;

&lt;p&gt;-F 尝试修复已损坏的压缩文件            -T 检查备份文件内的每个文件是否正确无误&lt;/p&gt;

&lt;p&gt;-q 不显示指令执行过程               -g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件&lt;/p&gt;

&lt;p&gt;-u 更新压缩包内文件                  &lt;/p&gt;

&lt;p&gt;-f 更新压缩包内文件。如果符合条件的文件没有包含在压缩包中，则压缩后添加&lt;/p&gt;

&lt;p&gt;-$ 保存第一个被压缩文件所在磁盘的卷标           -j 只保存文件名称及其内容                &lt;/p&gt;

&lt;p&gt;-D 压缩文件内不建立目录名称           -i &lt;表达式&gt; 压缩目录时，只压缩符合条件的文件&lt;/表达式&gt;&lt;/p&gt;

&lt;p&gt;-x &lt;表达式&gt; 排除符合条件的文件               -n &lt;文件名后缀&gt; 排除指定文件名后缀的文件&lt;/文件名后缀&gt;&lt;/表达式&gt;&lt;/p&gt;

&lt;p&gt;-b &lt;缓存路径&gt; 指定临时文件目录               -d &lt;表达式&gt; 从压缩文件内删除指定的文件&lt;/表达式&gt;&lt;/缓存路径&gt;&lt;/p&gt;

&lt;p&gt;-t &lt;日期时间&gt; 把压缩文件的日期设成指定的日期&lt;/日期时间&gt;&lt;/p&gt;

&lt;p&gt;-o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同&lt;/p&gt;

&lt;p&gt;-A 调整可执行的自动解压缩文件                 -c 替每个被压缩的文件加上注释&lt;/p&gt;

&lt;p&gt;-z 替压缩文件加上注释               -k 使用MS-DOS兼容格式的文件名称。&lt;/p&gt;

&lt;p&gt;-l 压缩文件时，把LF字符置换成LF+CR字符。                 -ll 压缩文件时，把LF+CR字符置换成LF字符。&lt;/p&gt;

&lt;p&gt;unzip [参数] &lt;压缩文件&gt; [压缩包中将被释放的文件]&lt;/压缩文件&gt;&lt;/p&gt;

&lt;p&gt;解压zip压缩包文件&lt;/p&gt;

&lt;p&gt;-P &lt;密码&gt; zip压缩包的密码                 -d &lt;路径&gt; 指定解压路径            -n 解压缩时不覆盖原有文件&lt;/路径&gt;&lt;/密码&gt;&lt;/p&gt;

&lt;p&gt;-f 覆盖原有文件                  -o 不经询问，直接覆盖原有文件&lt;/p&gt;

&lt;p&gt;-u 覆盖原有文件，并将压缩文件中的其他文件解压缩到目录中&lt;/p&gt;

&lt;p&gt;-l 显示压缩文件内所包含的文件                  -t 检查压缩文件是否正确            -z 显示压缩包注释&lt;/p&gt;

&lt;p&gt;-Z unzip -Z等于执行zipinfo指令                   -j 不处理压缩文件中原有的目录路径&lt;/p&gt;

&lt;p&gt;-C 压缩文件中的文件名称区分大小写                  -L 将压缩文件中的全部文件名改为小写&lt;/p&gt;

&lt;p&gt;-s 将文件名中的空格转换下划线                  -X 解压缩时保留文件原来的UID/GID&lt;/p&gt;

&lt;p&gt;-q 执行时不显示任何信息                             -v 执行是时显示详细的信息&lt;/p&gt;

&lt;p&gt;-c 将解压缩的结果显示到屏幕上，并对字符做适当的转换&lt;/p&gt;

&lt;p&gt;-p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换&lt;/p&gt;

&lt;p&gt;-a 对文本文件进行必要的字符转换                       -b 不要对文本文件进行字符转换&lt;/p&gt;

&lt;p&gt;-x &lt;表达式&gt; 处理里排除压缩包中的指定文件                       -M 将输出结果送到more程序处理&lt;/表达式&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;7z&lt;/td&gt;
      &lt;td&gt;7za &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件]&lt;/压缩包&gt;&lt;/子命令&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;子命令&lt;/p&gt;

&lt;p&gt;a 添加       d 删除       e 解压       x 带路径解压    l 列表查看         t 测试        u 更新&lt;/p&gt;

&lt;p&gt;参数&lt;/p&gt;

&lt;p&gt;-m&lt;压缩方式&gt;            -m0=&lt;压缩算法&gt; 默认使用lzma                  -mx=&amp;lt;1~9&amp;gt; 压缩级别&lt;/压缩算法&gt;&lt;/压缩方式&gt;&lt;/p&gt;

&lt;p&gt;-mfb=64 number of fast bytes for LZMA = 64           -md=&lt;字典大小&gt; 设置字典大小，例如 -md=32m&lt;/字典大小&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-ms=&amp;lt;on&lt;/td&gt;
      &lt;td&gt;off&amp;gt; 是否固实压缩                -o&lt;输出目录&gt; 设置输出目录               -p[密码] 使用密码&lt;/输出目录&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;-r[数字] 递归，使用数字定义递归子目录的深度                   -sfx[&lt;模块名称&gt;] 使用自解压模块&lt;/模块名称&gt;&lt;/p&gt;

&lt;p&gt;-si 从标准输入设备读入数据               -so 将数据写入标准输出设备              -y 所有询问均回答Yes&lt;/p&gt;

&lt;p&gt;-w&lt;工作目录&gt;&lt;/工作目录&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;rar &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件&lt;/压缩包&gt;&lt;/子命令&gt;&lt;/td&gt;
      &lt;td&gt;文件列表&lt;/td&gt;
      &lt;td&gt;路径]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;子命令&lt;/p&gt;

&lt;p&gt;x 带路径解压              e 解压到当前目录               a 将文件添加到压缩包内            d 从压缩包中删除文件&lt;/p&gt;

&lt;p&gt;u 更新压缩包内文件           f 更新压缩包内文件，并添加压缩包内不存在的文件            m 添加并删除源文件&lt;/p&gt;

&lt;p&gt;r 修复                l 列表查看压缩包内文件信息 lt 更详细信息 lb 简短信息            c 添加压缩包注释&lt;/p&gt;

&lt;p&gt;cf &lt;文件名&gt; 将文件内容添加为注释&lt;/文件名&gt;&lt;/p&gt;

&lt;p&gt;cw &lt;文件名&gt; 将注释保存为文件&lt;/文件名&gt;&lt;/p&gt;

&lt;p&gt;t 测试压缩包              rr 添加恢复纪录                  rv 恢复到文件  &lt;/p&gt;

&lt;p&gt;参数&lt;/p&gt;

&lt;p&gt;-p&lt;密码&gt; 设置密码&lt;/密码&gt;&lt;/p&gt;

&lt;p&gt;-m&amp;lt;0~5&amp;gt; 设置压缩级别，数字越大，压缩级别越高&lt;/p&gt;

&lt;p&gt;搜索
whereis &lt;程序名称&gt;&lt;/程序名称&gt;&lt;/p&gt;

&lt;p&gt;查找软件的安装路径          &lt;/p&gt;

&lt;p&gt;-b 只查找二进制文件                   -m 只查找帮助文件            -s 只查找源代码        -u 排除指定类型文件&lt;/p&gt;

&lt;p&gt;-f 只显示文件名                  -B &lt;目录&gt; 在指定目录下查找二进制文件           &lt;/目录&gt;&lt;/p&gt;

&lt;p&gt;-M &lt;目录&gt; 在指定目录下查找帮助文件               -S &lt;目录&gt; 在指定目录下查找源代码&lt;/目录&gt;&lt;/目录&gt;&lt;/p&gt;

&lt;p&gt;locate &lt;文件名称&gt;&lt;/文件名称&gt;&lt;/p&gt;

&lt;p&gt;在文件索引数据库中搜索文件&lt;/p&gt;

&lt;p&gt;-d &lt;数据库路径&gt; 搜索指定数据库&lt;/数据库路径&gt;&lt;/p&gt;

&lt;p&gt;updatedb 更新文件索引数据库&lt;/p&gt;

&lt;p&gt;find [路径] &lt;表达式&gt;&lt;/表达式&gt;&lt;/p&gt;

&lt;p&gt;查找文件&lt;/p&gt;

&lt;p&gt;-name &lt;表达式&gt; 根据文件名查找文件&lt;/表达式&gt;&lt;/p&gt;

&lt;p&gt;-iname &lt;表达式&gt; 根据文件名查找文件，忽略大小写&lt;/表达式&gt;&lt;/p&gt;

&lt;p&gt;-path &lt;表达式&gt; 根据路径查找文件&lt;/表达式&gt;&lt;/p&gt;

&lt;p&gt;-ipath &lt;表达式&gt; 根据路径查找文件，忽略大小写&lt;/表达式&gt;&lt;/p&gt;

&lt;p&gt;-amin &lt;分钟&gt; 过去N分钟内访问过的文件&lt;/分钟&gt;&lt;/p&gt;

&lt;p&gt;-atime &lt;天数&gt; 过去N天内访问过的文件&lt;/天数&gt;&lt;/p&gt;

&lt;p&gt;-cmin &lt;分钟&gt; 过去N分钟内修改过的文件&lt;/分钟&gt;&lt;/p&gt;

&lt;p&gt;-ctime &lt;天数&gt; 过去N天内修改过的文件&lt;/天数&gt;&lt;/p&gt;

&lt;p&gt;-anewer &lt;参照文件&gt; 比参照文件更晚被读取过的文件&lt;/参照文件&gt;&lt;/p&gt;

&lt;p&gt;-cnewer &lt;参照文件&gt; 比参照文件更晚被修改过的文件&lt;/参照文件&gt;&lt;/p&gt;

&lt;p&gt;-size &lt;大小&gt; 根据文件大小查找文件，单位b c w k M G&lt;/大小&gt;&lt;/p&gt;

&lt;p&gt;-type &lt;文件类型&gt; 根据文件类型查找文件。b 块设备 c 字符设备 d 目录 p 管道文件 f 普通文件 l 链接 s 端口文件&lt;/文件类型&gt;&lt;/p&gt;

&lt;p&gt;-user &lt;用户名&gt; 按归属用户查找文件&lt;/用户名&gt;&lt;/p&gt;

&lt;p&gt;-uid &lt;uid&gt; 按UID查找文件&lt;/uid&gt;&lt;/p&gt;

&lt;p&gt;-group &lt;群组名&gt; 按归属群组查找文件&lt;/群组名&gt;&lt;/p&gt;

&lt;p&gt;-gid &lt;gid&gt; 按GID查找文件&lt;/gid&gt;&lt;/p&gt;

&lt;p&gt;-empty 查找空文件&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;grep &lt;字符串&gt;&lt;/字符串&gt;&lt;/td&gt;
      &lt;td&gt;“&lt;正则表达式&gt;&quot; [文件名]&lt;/正则表达式&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其它
echo &lt;字符串&gt;&lt;/字符串&gt;&lt;/p&gt;

&lt;p&gt;回显。较复杂的字符串，可以使用 “ 括起来。&lt;/p&gt;

&lt;p&gt;-n 输出内容不换行             -E 不解析脱字符                 -e 解析脱字符&lt;/p&gt;

&lt;p&gt;控制字符&lt;/p&gt;

&lt;p&gt;\ 反斜线             a 警告                b 退格                n 换行                r 回车                t 水平制表符&lt;/p&gt;

&lt;p&gt;clear&lt;/p&gt;

&lt;p&gt;消除屏幕&lt;/p&gt;

&lt;p&gt;alias &lt;输入内容&gt; &lt;实际内容&gt;&lt;/实际内容&gt;&lt;/输入内容&gt;&lt;/p&gt;

&lt;p&gt;别名，为命令指定一个别名，以简化输入。例如：&lt;/p&gt;

&lt;p&gt;alias ls=’ls –color=auto’&lt;/p&gt;

&lt;p&gt;alias ls=”l -CF”&lt;/p&gt;

&lt;p&gt;可以将您的定义保存在 ~/.bashrc 文件中。&lt;/p&gt;

&lt;p&gt;export &lt;变量名称&gt;&lt;/变量名称&gt;&lt;/p&gt;

&lt;p&gt;将变量导出为环境变量，常写变量赋值一同使用，例如：&lt;/p&gt;

&lt;p&gt;export PATH=”$PATH:xxx”&lt;/p&gt;

&lt;p&gt;其中 $PATH 表示变量 PATH 原值&lt;/p&gt;

&lt;p&gt;shutdown&lt;/p&gt;

&lt;p&gt;关闭计算机，向根进程 init 发送信号，更改 runlevel 为 0 (halt)&lt;/p&gt;

&lt;p&gt;-h 关闭电源                -r 重启               -n 强行关机，不向 init进程 发送信号&lt;/p&gt;

&lt;p&gt;-k 模拟关机，向登录者发送关机警告                   -t &lt;秒&gt; N秒后关机             time &lt;时间&gt; 定时关机&lt;/时间&gt;&lt;/秒&gt;&lt;/p&gt;

&lt;p&gt;-c [说明信息] 取消关机               -f 重启时忽略检测文件系统                 -F 重启时强制检测文件系统&lt;/p&gt;

&lt;p&gt;halt&lt;/p&gt;

&lt;p&gt;关闭计算机。 调用 shutdown -h ，结束系统进程，同步文件系统，停止内核。&lt;/p&gt;

&lt;p&gt;-n 不同步文件系统             -w 模拟关机，写 /var/log/wtmp 纪录          -f 不调用 shutdown ,强行关机&lt;/p&gt;

&lt;p&gt;-p 默认选项，关机时调用 poweroff             -i 关机前断开网络&lt;/p&gt;

&lt;p&gt;reboot&lt;/p&gt;

&lt;p&gt;重新启动计算机。参数与 halt 相似&lt;/p&gt;

&lt;p&gt;chroot &lt;路径&gt;&lt;/路径&gt;&lt;/p&gt;

&lt;p&gt;Change Root 更改根目录，重新定义会话的运行环境。&lt;/p&gt;

&lt;p&gt;用户管理
一些细节&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root 用户为根用户，也就是 系统管理员 拥有全部权限

一个用户只能拥有一个 GID ，但是还可以归属于其它附加群组

用户管理的重要配置文件：

/etc/passwd 用户名 密码位 UID 归属GID 姓名 $HOME目录 登录Shell

/etc/shadow 用户名 已加密密码 密码改动信息 密码策略

/etc/group 群组名 密码位 GID 组内用户

/etc/gshadow 群组密码相关文件，不重要

/etc/sudoers 用户名 权限定义 权限

可以使用 pwconv 命令创建影子密码，将 /etc/passwd 文件中的密码转换到 /etc/shadow 文件

su [用户名]

切换到其它用户，默认切换到root用户。提示密码为将切换用户密码

-f 快速切换，忽略配置文件                 -l 重新登录                 -m ，-p 不更改环境变量

-c &amp;lt;命令&amp;gt; 切换后执行命令，并退出切换

sudo [命令]

以其它用户的身份执行命令，默认以root的身份执行。提示密码为当前用户密码

-s 切换为root shell              -i 切换为root shell，并初始化             -u &amp;lt;用户名|UID&amp;gt; 执行命令的身份

-l 显示自己的权限

passwd [用户名]

设定用户密码

-d 清除密码                -l 锁定用户                 -e 使密码过期，在下次登录时更改密码

-S 显示密码认证信息                   -x &amp;lt;天数&amp;gt; 密码过期，最大使用时间          

-n &amp;lt;天数&amp;gt; 冻结密码，最小使用时间           -s 更改登录Shell                 -f 更改用户信息

示例：

$passwd

Changing password for user

(current) UNIX password: 原密码

Enter new UNIX password: 新密码

Retype new UNIX password: 确认新密码

chsh [-s &amp;lt;Shell&amp;gt;] [用户名]

更改登录Shell

usermod &amp;lt;用户名&amp;gt;

修改用户账号

-d &amp;lt;目录&amp;gt; 设定$HOME目录               -m 设定$HOME目录时自动建立                 

-s &amp;lt;Shell&amp;gt; 修改用户登录Shell              -l &amp;lt;新用户名&amp;gt; 修改为新用户名

-u &amp;lt;UID&amp;gt; 修改用户UID                      -g &amp;lt;群组名&amp;gt; 修改用户归属群组

-G &amp;lt;群组名&amp;gt; 修改用户归属附加群组          -L 锁定帐户                -U 解除锁定              

-e &amp;lt;过期时间&amp;gt; 设定用户账号过期时间                 -f &amp;lt;缓冲天数&amp;gt; 设定密码过期后多长时间关闭账号

-c &amp;lt;字符串&amp;gt; 修改用户备注

useradd &amp;lt;用户名&amp;gt;

新建用户

-d &amp;lt;目录&amp;gt; 设定$HOME目录               -m 自动建立$HOME目录           -M 不自动建立$HOME目录

-s &amp;lt;Shell&amp;gt; 修改用户登录Shell              -l &amp;lt;用户名&amp;gt; 修改为新用户名               -u &amp;lt;UID&amp;gt; 修改用户UID

-g &amp;lt;群组名&amp;gt; 修改用户归属群组                   -G &amp;lt;群组名&amp;gt; 修改用户归属附加群组

-n 不建立以用户名为名称的群组                 -e &amp;lt;过期时间&amp;gt; 设定用户账号过期时间

-f &amp;lt;缓冲天数&amp;gt; 设定密码过期后多长时间关闭账号                -c &amp;lt;字符串&amp;gt; 修改用户备注

-D [表达式] 更改预设值 （预设值保存于 /etc/default/useradd 文件中）

新建用户规则保存于 /etc/login.defs 文件中

新建用户默认文件保存于 /etc/skel/ 目录中。新建用户时，系统自动拷贝此目录下的文件至新建用户的 $HOME 目录

userdel &amp;lt;用户名&amp;gt;

删除用户

-r 删除用户相关文件和目录

id [用户名]

显示用户 UID GID 归属附加群组

finger [用户名]

显示用户信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进程管理
一些细节&lt;/p&gt;

&lt;p&gt;进程一般分为交互进程、批处理进程和守护进程三类。&lt;/p&gt;

&lt;p&gt;守护进程总是活跃，在系统启动时通过脚本自动启动，或由root启动，通常在后台运行。&lt;/p&gt;

&lt;p&gt;一个进程可以拥有子进程。当父进程终止时，它的子进程也随之终止；而子进程终止时，父进程通常可以继续运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;init 进程为根进程，所有进程都是它的子进程

ps

显示进程信息，参数可省略 -

aux 以BSD风格显示进程(常用)                   -efH 以System V风格显示进程

-e , -A 显示所有进程           a 显示终端上所有用户的进程             x 显示无终端进程

u 显示详细信息                   f 树状显示                  w 完整显示信息                  l 显示长列表
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps alx 另一种常用输出格式

ps aux | less 将输出通过管道，使用 less 查看

ps aux | grep &amp;lt;关键字&amp;gt; 通过关键字查找进程

输出字段

USER 进程所有者               PID 进程ID               PPID 父进程              %CPU CPU占用率

%MEM 内存占用率           NI 进程优先级。数值越大，占用CPU时间越少                  VSZ 进程虚拟大小

RSS 页面文件占用              TTY 终端ID              STAT 进程状态                  

D 不可中断 Uninterruptible sleep (usually IO)               R 正在运行，或在队列中的进程                 

S 处于休眠状态                   T 停止或被追踪                  Z 僵尸进程                

W 进入内存交换（从内核2.6开始无效）           X 死掉的进程            &amp;lt; 高优先级                 N 低优先级

L 有些页被锁进内存          s 包含子进程              + 位于后台的进程组；

l 多线程，克隆线程 multi-threaded (using CLONE_THREAD, like NPTL pthreads do)

pstree

树状显示进程信息

-a 显示完整命令及参数               -c 重复进程分别显示                   -c 显示进程ID PID   -n 按 PID 排列进程

pgrep &amp;lt;进程名&amp;gt;

显示进程的PID

-l 显示进程名和进程PID            -o 进程起始ID           -n 进程终止ID

xkill

在图形界面中点杀进程。执行此命令后，鼠标指针变为骷髅图案（一定看过《加勒比海盗》吧）。在窗口中点击左键杀死进程，右键取消

pkill &amp;lt;进程名&amp;gt;

结束进程族。如果结束单个进程，请用 kill

kill [信号代码] &amp;lt;进程PID&amp;gt;

根据PID向进程发送信号，常用来结束进程，默认信号为 -9

-l [信号数字] 显示、翻译信号代码

-9 , -KILL 发送 kill 信号退出

-6 , -ABRT 发送 abort 信号退出

-15 , -TERM 发送 Termination 信号

-1 , -HUP 挂起

-2 , -INT 从键盘中断，相当于 Ctrl+c

-3 , -QUIT 从键盘退出，相当于 Ctrl+d

-4 , -ILL 非法指令

-11 , -SEGV 内存错误

-13 , -PIPE 破坏管道

-14 , -ALRM

-STOP 停止进程，但不结束

-CONT 继续运行已停止的进程

-9 -1 结束当前用户的所有进程

renice &amp;lt;优先级表达式&amp;gt; &amp;lt;进程表达式&amp;gt;

重新设定进程优先级（无此必要）

优先级表达式：

+|-|= &amp;lt;nice值&amp;gt;

nice取值范围： -20~19

进程表达式：

-p &amp;lt;PID&amp;gt; 通过进程ID进行设定

-g &amp;lt;PGID&amp;gt; 通过进程群组ID

-u &amp;lt;UID&amp;gt; 通过进程拥有者UID设定

top

动态、交互式进程管理器

-c 显示进程启动状态，包括参数、操作对象等；而不只是进程名

-d &amp;lt;秒&amp;gt; 刷新频率。 -d 5，表示5秒刷新一次

-n &amp;lt;次&amp;gt; 刷新次数，然后退出。 -n 5，表示刷新5次后退出；

-b 以批量模式运行，让输出能够使用管道或重定向。但不能进行交互，最好和 -n &amp;lt;次&amp;gt; 参数一同使用

-i 禁止显示空闲进程或僵尸进程；

-p PID 仅监视指定进程的ID；PID是一个数值；

-s 安全模式运行，禁用一些效互指令；

-S 累积模式，输出每个进程的总的CPU时间，包括已死的子进程；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;交互命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt; space &amp;gt; 立即刷新

k 交互式杀死进程，提示输入进程 PID （默认发送信号15）

r 设定renice，提示输入PID和renice值

s 改变两次刷新时间间隔，以秒为单位

n 设定显示进程数， 0 为不作限制

i 隐藏空闲进程和僵尸进程

S 切换到累积时间模式

l 开关，在顶部显示 uptime 信息

t 开关，在顶部显示 进程和CPU状态

m 开关，在顶部显示 free 信息

c 显示方式切换： 进程名/进程启动状态

A 按进程启动顺序进行排序。由新到旧

M 按内存占用排序。由大到小

N 以进程ID排序。由大到小

P 按CPU占用排序。由大到小

T 按时间／累积时间排序

f ，F 设定显示字段。设定完成后空格退出

o,O 设定显示字段的排序。大写向前移动，小写向后移动，空格退出

h,? 显示有关安全模式和累积模式的帮助信息

W 把当前的配置写到~/.toprc中；

nohup &amp;lt;命令&amp;gt;

将任务提交到后台，输出附加到 ~/nohup.out 文件。即便用户退出登录，提交的命令仍继续执行。

&amp;lt;命令&amp;gt; &amp;amp;

背景执行此命令，如果用户退出登录，则命令停止执行

&amp;lt;命令1&amp;gt; ; &amp;lt;命令2&amp;gt; ; ......

命令队列，从左向右，依次执行以 ; 分隔的命令

&amp;lt;命令1&amp;gt; &amp;amp;&amp;amp; &amp;lt;命令2&amp;gt; &amp;amp;&amp;amp; ......

命令队列，从左向右，依次执行以 &amp;amp;&amp;amp; 分隔的命令。前一个命令执行成功，后一个命令才能执行

&amp;lt;命令&amp;gt; &amp;lt;Ctrl+z&amp;gt;

&amp;lt;Ctrl+z&amp;gt; 挂起当前Shell中的任务

jobs

显示背景任务

bg [任务编号]

将挂起的任务背景执行

fg [任务编号]

将背景任务调到前台执行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计划任务&lt;/p&gt;

&lt;p&gt;磁盘和内存管理
一些细节&lt;/p&gt;

&lt;p&gt;Linux中，设备用/dev/目录下的文件表示。例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/hda1 第一块硬盘的第一主分区

/dev/hdb5 第二块硬盘的第一逻辑分区

/dev/sda4 第一块SATA硬盘的第四主分区，或者扩展分区

/dev/null 黑洞设备
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于磁盘设备，详见 分区概念&lt;/p&gt;

&lt;p&gt;mount &lt;设备文件&gt; [挂载路径]&lt;/设备文件&gt;&lt;/p&gt;

&lt;p&gt;挂载文件系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-t 指定文件系统的类型。通常不必指定，mount自动检测。下面是常用的格式

reiserfs ReiserFS 3.6版

jfs IBM技术

xfs SGI技术(适合高级服务器，桌面用户慎用)

ext3 Linux传统文件系统

vfat fat fat32

ext2 不带日志的ext3

ntfs WINNT

iso9660 光盘

smbfs Windows文件共享

-o [选项1] [选项2] ......

loop 环设备。光盘、ISO镜像等

ro | rw 只读readonly；可读写read-write

sync | async 同步模式|异步模式。决定修改是否立即写入文件系统

atime | noattime 读取时是否修改访问时间。对于写入敏感设备，例如闪存、软盘，建议使用 *noatime*

auto | noauto 自动挂载模式

exec | noexec 是否允许可执行权限

defaults 使用预设的选项 rw, suid, dev, exec, auto, nouser, async

iocharset=UTF-8 指定字符集，可简写为 utf8

codepage=936 指定代码页，可简写为 cp936 西文系统代码页为 437

umask=&amp;lt;权限掩码&amp;gt; 设定权限掩码

uid=&amp;lt;UID&amp;gt; 设定归属用户

gid=&amp;lt;GID&amp;gt; 设定归属群组

remount 以不同选项重新挂载

-L &amp;lt;卷标&amp;gt; 将带有特殊卷标的分区
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tip&lt;/p&gt;

&lt;p&gt;权限掩码&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;权限=777-权限掩码（三位）&lt;/td&gt;
      &lt;td&gt;7777-权限掩码（四位）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;假如权限掩码为 022 ，则新建对象权限为 755 rwxr-xr-x&lt;/p&gt;

&lt;p&gt;可以使用 umask 命令设置权限掩码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mount -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;挂载 /etc/fstab 文件中定义的所有设备&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount -t iso9660 -o loop /dev/cdrom0 /media/cdrom

sudo mount -t vfat -o remount iocharset=utf8,codepage=cp936 /dev/hda5 /media/hda5

umount &amp;lt;设备文件&amp;gt; | &amp;lt;挂载路径&amp;gt;

卸载已挂载文件系统

df

查看已挂载文件系统的磁盘空间占用

-a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统

-T 显示文件系统类型                  -k 以k字节为单位显示              -i 显示i节点信息，而不是磁盘块

-t &amp;lt;文件系统类型&amp;gt; 显示指定类型的文件系统的磁盘空间使用情况

-x &amp;lt;文件系统类型&amp;gt; 列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。

-l 只显示本地文件系统

free

查看内存、缓冲区、交换空间的占用

-b 以字节为单位显示数值           -k 以千字节为单位显示数值                -m 以兆字节为单位显示数值

-g 以吉字节为单位显示数值                -l 显示内存占用峰值          -o 不显示缓冲区占用                   -t 统计结果

-s &amp;lt;秒&amp;gt; 刷新频率

sync

同步文件系统。将缓冲区中的数据写入文件系统

fdisk &amp;lt;磁盘设备文件&amp;gt;

分区表修改工具

交互命令：

m 使用帮助                l 查看已知文件系统类型             p 显示分区信息

n 新建分区 （p:主分区 l:扩展分区 参见 分区概念 )          d 删除分区                 t 改变分区类型

w 将改动写入分区表                   q 放弃改动并退出              

* 磁盘设备名称为整块磁盘，而不是磁盘中的分区。例如 /dev/hda ，而不是 /dev/hda1

fdisk -l

查看所有磁盘分区信息

cfdisk

更加友善的分区表修改工具

mkfs.&amp;lt;文件系统类型&amp;gt; &amp;lt;分区设备文件&amp;gt;

将分区格式化为文件系统。 文件系统类型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkfs.reiserfs /dev/hda1

mkfs &amp;lt;分区设备文件&amp;gt;

-t &amp;lt;文件系统类型&amp;gt; 指定文件系统类型                  -c 格式化前检查磁盘

mkisofs -o &amp;lt;镜像文件&amp;gt; [源文件目录]

用光盘或者文件制作iso镜像

-b 可启动镜像

hdparm &amp;lt;磁盘设备文件&amp;gt;

设置硬盘参数

-d &amp;lt;0|1&amp;gt; DMA模式开关              -a &amp;lt;0|1&amp;gt; 预计模式开关                 -t 性能测试                 -T 缓存性能测试

-c &amp;lt;0|1|3&amp;gt; 32位传输模式开关               -g 显示柱面，扇区等信息           -i -I 显示磁盘信息

网络和硬件管理

ifconfig

配置网络接口

-a 显示所有网络接口

ifconfig &amp;lt;网卡&amp;gt; up|down

激活|禁用网卡

示例：

sudo ifconfig eth0 up

ifconfig &amp;lt;网卡&amp;gt; add &amp;lt;IP地址&amp;gt; [ netmask &amp;lt;子网掩码&amp;gt; ]

给网卡指定IP地址或子网掩码

route

配置路由及网关

route add -net &amp;lt;路由地址&amp;gt; gw &amp;lt;网关地址&amp;gt; [ netmask &amp;lt;子网掩码&amp;gt; ] dev &amp;lt;网卡&amp;gt;

指定路由及网关

route del -net &amp;lt;网关地址&amp;gt; gw &amp;lt;网关地址&amp;gt; [ netmask &amp;lt;子网掩码&amp;gt; ]

删除路由及网关

ip

配置网络

子命令：

link 网卡配置             address 配置地址。相当于 ifconfig               route 配置路由。相当于 route

参数：

show 显示(默认)                 set 设置             add 添加            del 删除
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip link show 显示网卡配置

ip link set eth0 name xxx 重命名网络接口

ping &amp;lt;IP地址&amp;gt;

向目标地址发送ICMP封包，常用来测试网络

-b &amp;lt;广播地址&amp;gt; ping整个网段               -c 发送封包次数                  -s &amp;lt;封包大小&amp;gt; 默认为64字节

netstat

网络连接状态

-r 显示路由表，同 route             -a 所有连接                -t 只显示TCP协议            -U 只显示UDP协议

-l 只显示正在监听的端口            -p 显示PID和进程名                  -c &amp;lt;秒&amp;gt; 刷新频率               

* http/ftp/ssh…… 为应用层协议                  * TCP/UDP为传输层协议           * IP/ICMP为网络层协议

lspci

查看PCI总线连接的设备

lsusb

查看USB接口连接的设备

lsmod

查看已加载模块

* /lib/modules/uname -r 目录下为所有可用模块

modprobe &amp;lt;模块名称&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;vim&quot;&gt;简明VIM教程&lt;/h1&gt;
&lt;p&gt;VIM简介&lt;/p&gt;

&lt;p&gt;我们使用的大多数编辑器，都可以直接在编辑区输入字符，并且能够通过一些快捷键来完成一些控制功能，比如使用方向键移动光标，使用&lt;/p&gt;

&lt;p&gt;BackSpack 或者 Delete 键删除文字，使用 PgUp 和 PgDn 翻页，使用 Home 和 End 来定位行首和行末……&lt;/p&gt;

&lt;p&gt;而Vim是一个带模式的编辑器，同样的按键，在不同模式下，具有不同的功能定义。例如 h j k l 在 编辑模式 下输入相应的字符，在 普通模式 下却相当于方向键的作用。&lt;/p&gt;

&lt;p&gt;由于需要切换模式，Vim的使用起来略显繁琐。不过优点也显而易见：您只要把手安安稳稳的放在打字区就可以了，而不需要使用诸如方向键、排版键、小键盘等&lt;/p&gt;

&lt;p&gt;需要挪开双手的键位，从而提高了您的效率和专注程度。事实上，Vim的前身Vi诞生的时候，键盘上还没有方向键、排版键和小键盘：）&lt;/p&gt;

&lt;p&gt;命令&lt;/p&gt;

&lt;p&gt;使用Vim编辑文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi [文件名]

vim [文件名]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;教学模式:&lt;/p&gt;

&lt;p&gt;vimtutor [语言]&lt;/p&gt;

&lt;p&gt;vim教程，相当于使用Vim编辑器以只读模式打开教程文件。您无论对这个文件作了什么，都会在退出后恢复原来的样貌。与只读模式的区别在于，它不会没有眼色的提醒您，现在的状态为只读模式。您可以使用它作一些练习&lt;/p&gt;

&lt;p&gt;您可以指定教程文件的语言，如果使用本地语言(ZH_cn)出现乱码，您可以尝试使用英语&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vimtutor en
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用Vim比较文件区别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vimdiff [文件1] [文件2] [其它文件]……
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件&lt;/p&gt;

&lt;p&gt;Vim的全局配置文件为 /etc/vim/vimrc ，用户配置文件为 ~/.vimrc ， “ 起始的行为注释行。我们提供的配置项，您直接加入配置文件就可以了&lt;/p&gt;

&lt;p&gt;您可以先对Vim进行一些简单的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;设定文件编码

set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936

&quot;开启语法加亮

syntax on

&quot;配色风格

colorscheme pablo

&quot;设定行距 GUI界面中生效

set linespace=4

&quot;设定GUI选项

&quot;set guioptions=gmrLtT m:菜单 T:工具栏

set guioptions=gmrLt

&quot;设定Tab键缩进的空格数

set tabstop=4

&quot;设定编辑器将多少空格视为一个缩进

set shiftwidth=4

&quot;将缩进转换为空格

&quot;set expandtab

&quot;设定折叠方式

&quot;set foldmethod=indent

&quot;以下字符将被视为单词的一部分 (ASCII)：

&quot;set iskeyword+=33-47,58-64,91-96,123-128
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;模式介绍&lt;/p&gt;

&lt;p&gt;Vim常见的模式有： 普通模式 、 插入模式 、 命令模式 ，另外我们也会经常用到 可视模式 。&lt;/p&gt;

&lt;p&gt;Vim启动时进入 普通模式 ；或者在其它模式下，按下 Esc 键，便可以回到普通模式。&lt;/p&gt;

&lt;p&gt;使用 vimtutor en 命令进入教程，现在是普通模式。随便按几下 j 、 k 、 l 、 h 键，您会发现光标的位置发生改变。&lt;/p&gt;

&lt;p&gt;按下 i 键，编辑器底部出现了 – 插入 – 或者 – insert – ，您进入了插入模式。随便按几下 j 、 k 、 l、 h，您会发现相应的字符出现在编辑区，现在还可以通过方向键来移动光标。可能您觉得使用方向键移动光标不是什么问题，但是习惯了Vim后，您会认为方向键太麻烦了，简直不能容忍！好了，现在按下 Esc 键回到普通模式，我们又可以使用 j 、 k 、 l 、 h 来移动光标了。&lt;/p&gt;

&lt;p&gt;在普通模式下，按下 : 键（也就是 Shift+; ），在编辑器底部出现了一个 : ，您进入了命令模式。在 : 后输入一个命令 new ，回车后，编辑器被分割为上下两栏。为了方便起见，我们在命令前加一个 : 来表示命令模式下输入的命令，像这样&lt;/p&gt;

&lt;p&gt;:vnew&lt;/p&gt;

&lt;p&gt;一个命令能够以一些规则简化，上面的命令也可以写为这种形式&lt;/p&gt;

&lt;p&gt;:vne&lt;/p&gt;

&lt;p&gt;现在您的编辑区一定弄的四分五裂，您可以使用命令“:quit”来关闭当前栏，直接用简写就可以了&lt;/p&gt;

&lt;p&gt;:q&lt;/p&gt;

&lt;p&gt;这个命令是退出编辑器，如果编辑区被分成多栏，则是退出当前栏。&lt;/p&gt;

&lt;p&gt;执行完一个命令（按下回车后），编辑器会自动回到普通模式。如果您想不执行当前命令，直接回到普通模式，您可以按下Esc键。&lt;/p&gt;

&lt;p&gt;按下 v 键，您进入了可视模式，可以使用 j 、 k 、 l 、 h 移动光标，高亮选取文本 。&lt;/p&gt;

&lt;p&gt;事实上，可视模式相当于高亮选取文本后的普通模式。&lt;/p&gt;

&lt;p&gt;可视模式具有子模式，以行为单位进行选取的可视行模式，使用 V 键进入（也就是 Shift+v ）；和以块为单位进行选取的可视块模式，使用 Ctrl+v 键进入。&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Dec 2015 22:30:45 +0800</pubDate>
        <link>http://javictory.info/ubuntu/2015/12/22/ubuntu-Instruction.html</link>
        <guid isPermaLink="true">http://javictory.info/ubuntu/2015/12/22/ubuntu-Instruction.html</guid>
        
        
        <category>Ubuntu</category>
        
      </item>
    
      <item>
        <title>常见字符集区别：</title>
        <description>&lt;p&gt;1、LPTSTR、LPCSTR、LPCTSTR、LPSTR的意义：&lt;/p&gt;

&lt;p&gt;(1) LPSTR：32bit指针 指向一个字符串，每个字符占1字节；&lt;/p&gt;

&lt;p&gt;(2) LPCSTR：32-bit指针 指向一个常字符串，每个字符占1字节；&lt;/p&gt;

&lt;p&gt;(3) LPCTSTR：32-bit指针 指向一个常字符串,每字符可能占1字节或2字节，取决于Unicode是否定义，T表示在Win32环境中， 有一个_T宏；&lt;/p&gt;

&lt;p&gt;(4) LPTSTR：32-bit指针 每字符可能占1字节或2字节，取决于Unicode是否定义。&lt;/p&gt;

&lt;p&gt;2、Multi-Byte Character Set：&lt;/p&gt;

&lt;p&gt;MBCS，它是多字节字符集，它是不定长表示世界文字的编码。&lt;/p&gt;

&lt;p&gt;MBCS表示英文字母时就和ASCII一样（这也是我们容易把MBCS和ASCII搞混的原因），但表示其他文字时就需要用多字节。&lt;/p&gt;

&lt;p&gt;WINDOWS下面的程序设计可以支持MBCS和UNICODE两种编码的字符串，具体用那种就看你定义了MBCS宏还是UNICODE宏。&lt;/p&gt;

&lt;p&gt;MBCS宏对应的字符串指针是char* 也就是LPSTR；&lt;/p&gt;

&lt;p&gt;UNICODE对应的指针是unsigned  short* 也就是LPWSTR；&lt;/p&gt;

&lt;p&gt;为了写程序方便，微软定义了类型LPTSTR，在MBCS下他就是char* ,   在UNICODE下它是unsigned   char* ,这样你就可以重定义一个宏进行不同字符集的转换了。&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Dec 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/windows/2015/12/08/win-common-charset.html</link>
        <guid isPermaLink="true">http://javictory.info/windows/2015/12/08/win-common-charset.html</guid>
        
        
        <category>Windows</category>
        
      </item>
    
      <item>
        <title>C++ 基础</title>
        <description>&lt;p&gt;基本语法&lt;/p&gt;

&lt;p&gt;1、全局变量个局部变量&lt;/p&gt;

&lt;p&gt;如下面的这一串代码&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;#include &amp;lt;iostream&amp;gt;

  #include &amp;lt;stdlib.h&amp;gt;

  using namespace std;
  
  int vac=3;

  int main(){

  	int vac=10;
  	::vac++;
  	cout&amp;lt;&amp;lt;::vac&amp;lt;&amp;lt;endl;
  	cout&amp;lt;&amp;lt;vac&amp;lt;&amp;lt;endl;
  	system(&amp;quot;pause&amp;quot;);
  	return 0 ;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;其中，有几个地方需要做一下说明：&lt;/p&gt;

&lt;p&gt;(1)在调试的时候，想要让弹出console的时候停止 需要添加system(“pause”)，方便进行观看。&lt;/p&gt;

&lt;p&gt;(2)::是域操作符，::前面可以是 类名，命名空间名 来限定 ::后面的内容从哪里读取，在这里如果 ::前面没有域名 那么就是全局；：：vac代表的即是全局变量。&lt;/p&gt;

&lt;p&gt;(3)而在main函数里面定义的 vac函数则是局部变量。&lt;/p&gt;

&lt;p&gt;2、变量初始化&lt;/p&gt;

&lt;p&gt;形式：&lt;变量名&gt;(表达式)&lt;/变量名&gt;&lt;/p&gt;

&lt;p&gt;例如：int a(4); //与C语言中的int a=4;是等价的。&lt;/p&gt;

&lt;p&gt;3、C++符号常量 const&lt;/p&gt;

&lt;p&gt;C++有符号常量而C中是没有的&lt;/p&gt;

&lt;p&gt;C++的格式： const &lt;类型&gt;&lt;符号常量&gt;=值;&lt;/符号常量&gt;&lt;/类型&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如 ：const float PI=3.1415926; // C为 #define PI 3.1415926;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1)与C相比，用const定义的符号常量具有数据类型，而且作用域可以是局部的。&lt;/p&gt;

&lt;p&gt;(2)const 可以是参数指针不被改变&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 例如： int sum(const int *a);    (3)调用时，不想改变引用变量a的值

 例如： void f(const int &amp;amp;a,int b){...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、自增判断&lt;/p&gt;

&lt;p&gt;#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;#define product(x) (x*x);&lt;/p&gt;

&lt;p&gt;int main(){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i=3,j,k;

j=product(i++);//此处的表达式为(i++)*(i++)，运行结束后，i==5；

k=product(++i);//此处的表达式为(++i)*(++i),在得到运算结果之前，i==7

cout&amp;lt;&amp;lt;&quot;j=&quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&quot;k=&quot;&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl;

system(&quot;pause&quot;);

return 0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5、在VC++ 编写dll时应当注意在.c文件和在.CPP文件下的区别。      &lt;br /&gt;
   在.cpp文件下无论是动态链接库的创建还是调用，都要声明一下extern “C” ；&lt;/p&gt;

&lt;p&gt;6、在C中是没有string类型的，因此都是用字符数组进行
   字符数组也没有办法直接进行字符串的赋值
   只有在初始化的时候可以直接进行赋值&lt;/p&gt;

&lt;p&gt;7、main函数中参数的意义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main(int argc, char* argv[])
{
	return 0;
}    两个参数是给读入命令行参数的：
&lt;/code&gt;&lt;/pre&gt;

   	argc表示参数个数，Count;

   	argv[]存放参数，Value;
</description>
        <pubDate>Tue, 01 Dec 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/c++/2015/12/01/C++-Basic.html</link>
        <guid isPermaLink="true">http://javictory.info/c++/2015/12/01/C++-Basic.html</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>VC++中动静态链接库的调用</title>
        <description>&lt;p&gt;1、动态链接库在调用时要注意:&lt;/p&gt;

&lt;p&gt;格式为hdll=LoadLibrary（“DLL地址”）；&lt;/p&gt;

&lt;p&gt;这里字符串类型是LPSTR，当VS中工程属性设置是unicode字符集的时候会提示错误，
   因此要在配置-Property-General-&amp;gt;Character Set 里面把默认字符集“unicode”改成支持多字符扩展或者notset即可。&lt;/p&gt;

&lt;p&gt;2、动态链接库DLL的调用分为动态调用和静态调用&lt;/p&gt;

&lt;p&gt;(1)DLL的静态调用&lt;/p&gt;

&lt;p&gt;在程序中要静态调用一个dll文件，一般会有下面这么一句 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pragma comment(lib, &quot;dll2.lib&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然这不是必须的，也可以通过工程 设置 链接 添加这个lib。&lt;/p&gt;

&lt;p&gt;意思是要把dll2.lib这个文件的信息编译到exe这个程序当中的，所以你必须把你的dll2.lib和dll2.dll都得放入exe所在的文件夹；&lt;/p&gt;

&lt;p&gt;dll2.lib是用于编译的时候用的，  dll2.dll是当exe文件执行的时候用的；&lt;/p&gt;

&lt;p&gt;当编译好了以后 这个dll2.lib文件就没有用了 ，因为它的信息已经编译到exe中了；&lt;/p&gt;

&lt;p&gt;所以当你发布的时候 就可以把这个dll2.lib删除了，只留下dll2.dll就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如：

#include &amp;lt;iostream&amp;gt;
#pragma comment(lib,&quot;Mydll2.lib&quot;)
extern &quot;C&quot; __declspec(dllimport) int add(int x,int y);
int main(int argc, char* argv[])
{
	int result = add(2,3);
	printf(&quot;%d&quot;,result);
	getchar();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2)DLL的动态调用：&lt;/p&gt;

&lt;p&gt;只需要dll就可以了，和lib一点关系都没有。&lt;/p&gt;

&lt;p&gt;可以用Extern，也可以用.def文件导出函数接口，供外部工程调用。&lt;/p&gt;

&lt;p&gt;动态链接库在调用时要注意： &lt;/p&gt;

&lt;p&gt;格式为hdll=LoadLibrary（“DLL地址”）；&lt;/p&gt;

&lt;p&gt;这里字符串类型是LPSTR，不是unicode字符，
   因此要配置 -Property-General-&amp;gt;Character Set 里面把默认字符集“unicode”改成支持多字符扩展或者notset即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如：

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;windows.h&amp;gt; 
typedef int(*lpAddFun)(int , int);

int main(int argc, char* argv[])
{
	HINSTANCE hDll;
	lpAddFun addFun;
	hDll = LoadLibrary(&quot;Mydll2.dll&quot;);
	if (hDll != NULL)
	{
		addFun = (lpAddFun)GetProcAddress(hDll, &quot;add&quot;);
		if (addFun != NULL)
		{
			int result = addFun(2, 3);
			printf(&quot;%d&quot;, result);
	   	 	getchar();
		}
		FreeLibrary(hDll);
	}
   	 	getchar();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、DLL工程和实际引用工程联调&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Nov 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/c++/2015/11/12/C++-DLL.html</link>
        <guid isPermaLink="true">http://javictory.info/c++/2015/11/12/C++-DLL.html</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>Ubuntu 常用快捷键</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;一、桌面&lt;/h1&gt;

&lt;p&gt;ALT + F1: 聚焦到桌面左侧任务导航栏，可按上下键导航。&lt;/p&gt;

&lt;p&gt;ALT + F2: 运行命令&lt;/p&gt;

&lt;p&gt;ALT + F4: 关闭窗口&lt;/p&gt;

&lt;p&gt;ALT + TAB: 切换程序窗口&lt;/p&gt;

&lt;p&gt;ALT + 空格: 打开窗口菜单&lt;/p&gt;

&lt;p&gt;PRINT: 桌面截图&lt;/p&gt;

&lt;p&gt;SUPER: 打开Dash面板，可搜索或浏览项目，默认有个搜索框，按“下”方向键进入浏览区域（SUPER键指Win键或苹果电脑的Command键）&lt;/p&gt;

&lt;p&gt;在Dash面板中按CTRL + TAB: 切换到下一个子面板（可搜索不同类型项目，如程序、文件、音乐）&lt;/p&gt;

&lt;p&gt;SUPER + A: 搜索或浏览程序（Application）&lt;/p&gt;

&lt;p&gt;SUPER + F: 搜索或浏览文件（File）&lt;/p&gt;

&lt;p&gt;SUPER + M: 搜索或浏览音乐文件（Music）&lt;/p&gt;

&lt;h1 id=&quot;terminal&quot;&gt;二、Terminal终端&lt;/h1&gt;

&lt;p&gt;CTRL + ALT + T: 打开终端&lt;/p&gt;

&lt;p&gt;TAB: 自动补全命令或文件名&lt;/p&gt;

&lt;p&gt;CTRL + SHIFT + V: 粘贴（Linux中不需要复制的动作，文本被选择就自动被复制）&lt;/p&gt;

&lt;p&gt;CTRL + SHIFT + T: 新建标签页&lt;/p&gt;

&lt;p&gt;CTRL + D: 关闭标签页&lt;/p&gt;

&lt;p&gt;CTRL + L: 清除屏幕&lt;/p&gt;

&lt;p&gt;CTRL + R + 文本: 在输入历史中搜索&lt;/p&gt;

&lt;p&gt;CTRL + A: 移动到行首&lt;/p&gt;

&lt;p&gt;CTRL + E: 移动到行末&lt;/p&gt;

&lt;p&gt;CTRL + C: 终止当前任务&lt;/p&gt;

&lt;p&gt;CTRL + Z: 把当前任务放到后台运行（相当于运行命令时后面加&amp;amp;）&lt;/p&gt;

&lt;p&gt;~: 表示用户目录路径&lt;/p&gt;

&lt;h1 id=&quot;nautilus&quot;&gt;三、Nautilus文件管理器&lt;/h1&gt;

&lt;p&gt;启动Nautilus的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;SUPER + 1，这个方法仅适用于Nautilus在左边快速启动的位置没有改变的情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SUPER + A，然后输入nautilus，然后回车&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;F2: 重命名&lt;/p&gt;

&lt;p&gt;CTRL + 1: 图标视图&lt;/p&gt;

&lt;p&gt;CTRL + 2: 列表视图&lt;/p&gt;

&lt;p&gt;CTRL + T: 新建标签页&lt;/p&gt;

&lt;p&gt;CTRL + W: 关闭标签页&lt;/p&gt;

&lt;p&gt;CTRL + D: 收藏到书签&lt;/p&gt;

&lt;p&gt;CTRL + Q: 退出&lt;/p&gt;

&lt;p&gt;Nautilus还有很多和Firefox一致的快捷键。&lt;/p&gt;

&lt;h1 id=&quot;firefox&quot;&gt;四、Firefox浏览器&lt;/h1&gt;
&lt;p&gt;进入Firefox的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;SUPER + A，然后按firefox，回车。这个是在Dash面板中搜索应用程序运行。事实上，只要按fir就能定位到Firefox程序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ALT，然后按firefox，回车。这个相当于在命令行运行一条命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在终端中按firefox&amp;amp;，回车。这个适用于以终端作为主要操作窗口的用户，使用TAB键还可以自动补全命令（只需输入前几个字母再按TAB键）。&amp;amp;在shell中是后台运行的意思，这样终端就不会被Firefox独占。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CTRL + T: 新建标签页&lt;/p&gt;

&lt;p&gt;CTRL + W: 关闭标签页&lt;/p&gt;

&lt;p&gt;CTRL + SHIFT + T: 重新打开最近关闭的一个标签页&lt;/p&gt;

&lt;p&gt;CTRL + TAB: 切换到下一个标签页&lt;/p&gt;

&lt;p&gt;CTRL + SHIFT + TAB: 切换到上一个标签页&lt;/p&gt;

&lt;p&gt;ALT + [1-8]: 跳到制定标签页&lt;/p&gt;

&lt;p&gt;ALT + 9: 跳到最后一个标签页&lt;/p&gt;

&lt;p&gt;CTRL + L: 跳到地址栏&lt;/p&gt;

&lt;p&gt;ESC: 停止加载当前页面&lt;/p&gt;

&lt;p&gt;CTRL + K: 跳到搜索引擎输入框&lt;/p&gt;

&lt;p&gt;CTRL + F: 在当前页面中搜索&lt;/p&gt;

&lt;p&gt;/: 快速查找。在Linux中很多程序（如VI、Man、Less）都使用/作为搜索的快捷键，并且可使用正则表达式查找。但在Firefox中没有正则表达式搜索的功能。&lt;/p&gt;

&lt;p&gt;CTRL + D: 收藏到书签&lt;/p&gt;

&lt;p&gt;ALT + 左方向键: 后退&lt;/p&gt;

&lt;p&gt;ALT + v: 前进&lt;/p&gt;

&lt;p&gt;CTRL + Q: 退出&lt;/p&gt;

&lt;h1 id=&quot;orca&quot;&gt;五、Orca读屏软件&lt;/h1&gt;

&lt;p&gt;启动Orca: SUPER + A，然后输入orca，然后回车&lt;/p&gt;

&lt;p&gt;ORCA + 空格: 显示首选项对话框（ORCA键是指Insert插入键或CAPS LOCK大小写转换键，取决于设置）&lt;/p&gt;

&lt;p&gt;ORCA + t: 读当前时间&lt;/p&gt;

&lt;p&gt;ORCA + tt: 读当前日期&lt;/p&gt;

&lt;p&gt;ORCA + s: 切换合成语音开关&lt;/p&gt;

&lt;p&gt;ORCA + /: 朗读标题&lt;/p&gt;

&lt;p&gt;ORCA + //: 朗读状态栏&lt;/p&gt;

&lt;p&gt;ORCA + 分号: 朗读整个文件&lt;/p&gt;

&lt;p&gt;ORCA + Q: 退出Orca&lt;/p&gt;

&lt;h1 id=&quot;rhythmbox&quot;&gt;六、Rhythmbox音频播放器&lt;/h1&gt;

&lt;p&gt;CTRL + 空格: 播放/暂停&lt;/p&gt;

&lt;p&gt;ALT + 右方向键: 下一首&lt;/p&gt;

&lt;p&gt;ALT + 左方向键: 上一首&lt;/p&gt;

&lt;p&gt;CTRL + 上方向键: 增大音量&lt;/p&gt;

&lt;p&gt;CTRL + 下方向键: 减少音量&lt;/p&gt;

&lt;p&gt;CTRL + U: 随机播放&lt;/p&gt;

&lt;p&gt;CTRL + R: 重复播放&lt;/p&gt;

&lt;p&gt;CTRL + Q: 退出&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;七、如何打开一个程序&lt;/h1&gt;

&lt;p&gt;以“系统配置”为例，先按SUPER + A，SUPER即Win键，然后切换到中文输入法，输入“系统配置”，按回车即打开程序。&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://javictory.info/ubuntu/2015/11/09/ubuntu-common-shortcutkey.html</link>
        <guid isPermaLink="true">http://javictory.info/ubuntu/2015/11/09/ubuntu-common-shortcutkey.html</guid>
        
        
        <category>Ubuntu</category>
        
      </item>
    
      <item>
        <title>VC++ 6.0 编译器相关设置</title>
        <description>&lt;p&gt;1、结构体中所有成员的对齐参数N的最大值称为结构体的对齐参数。 &lt;/p&gt;

&lt;p&gt;VC++6.0中n 默认是8个字节，可以修改这个设定的对齐参数；&lt;/p&gt;

&lt;p&gt;(1)方法一：&lt;/p&gt;

&lt;p&gt;在菜单“工程”的“设置”中的“C/C++”选项卡的“分类”中， “Code Generation ”的“Struct member alignment” 中设置：&lt;/p&gt;

&lt;p&gt;1byte、2byte、4byte、8byte、16byte等几种，默认为8byte。&lt;/p&gt;

&lt;p&gt;(2)方法二：&lt;/p&gt;

&lt;p&gt;可以程序控制，采用指令：
		#pragma   pack(xx)控制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 例如：
	#pragma   pack(1),1字节对齐，
	#pragma   pack(4)，4字节对齐，
	#pragma   pack(16)，16字节对齐   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们将分不同的情况来详细讨论结构体成员的分布情况，顺便提醒一下， 常见类型的长度：&lt;/p&gt;

&lt;p&gt;Int 4byte, Short 2byte, Char 1byte, Double 8byte, Long 4byte ；  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;让我们先看下例： 

Struct  A 
{
	char   c; //1byte  
	double d; //8byte  
	short s;  //2byte  
	int   i;  //4byte  
};  

int main(int argc, char* argv[]) 
{ 
	A  strua;
	printf(&quot;%len:d\n&quot;,sizeof(A));     
	printf(&quot;%d,%d,%d,%d&quot;,&amp;amp;strua.c,&amp;amp;strua.d,&amp;amp;strua.s,&amp;amp;strua.i);  
	return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;n设置为8byte时 结果：len:24, &lt;/p&gt;

&lt;p&gt;1245032,1245040,1245048,1245052 内存中成员分布如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://javictory.info/img/img_append/C++VS2008-1.png&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、用 devenv.exe /resetuserdata 恢复Visual Studio 初始状态&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Nov 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/c++/2015/11/08/C++-VS2008.html</link>
        <guid isPermaLink="true">http://javictory.info/c++/2015/11/08/C++-VS2008.html</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>DLL的入口函数_DLLMain</title>
        <description>&lt;p&gt;跟exe有个main或者WinMain入口函数一样，DLL也有一个入口函数，就是DllMain。对于动态链接库，DllMain是一个可选的入口函数。&lt;/p&gt;

&lt;p&gt;系统是在什么时候调用DllMain函数的呢？静态链接时，或动态链接时调用LoadLibrary和FreeLibrary都会调用DllMain函数。DllMain的第二个参数fdwReason指明了系统调用Dll的原因，它可能是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DLL_PROCESS_ATTACH

DLL_PROCESS_DETACH

DLL_THREAD_ATTACH

DLL_THREAD_DETACH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下从这四种情况来分析系统何时调用了DllMain。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;进程映射&lt;/h4&gt;

&lt;p&gt;DLL_PROCESS_ATTACH&lt;/p&gt;

&lt;p&gt;大家都知道，一个程序要调用Dll里的函数，首先要先把DLL文件映射到进程的地址空间。要把一个DLL文件映射到进程的地址空间，有两种方法：静态链接和动态链接的LoadLibrary或者LoadLibraryEx。&lt;/p&gt;

&lt;p&gt;当一个DLL文件被映射到进程的地址空间时，系统调用该DLL的DllMain函数，传递的fdwReason参数为DLL_PROCESS_ATTACH，这种调用只会发生在第一次映射时。如果同一个进程后来为已经映射进来的DLL再次调用LoadLibrary或者LoadLibraryEx，操作系统只会增加DLL的使用次数，它不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。不同进程用LoadLibrary同一个DLL时，每个进程的第一次映射都会用DLL_PROCESS_ATTACH调用DLL的DllMain函数。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-1&quot;&gt;进程卸载&lt;/h4&gt;

&lt;p&gt;DLL_PROCESS_DETACH&lt;/p&gt;

&lt;p&gt;当DLL被从进程的地址空间解除映射时，系统调用了它的DllMain，传递的fdwReason值是DLL_PROCESS_DETACH。当DLL处理该值时，它应该执行进程相关的清理工作。
那么什么时候DLL被从进程的地址空间解除映射呢？两种情况：&lt;/p&gt;

&lt;p&gt;◆FreeLibrary解除DLL映射（有几个LoadLibrary，就要有几个FreeLibrary）&lt;/p&gt;

&lt;p&gt;◆进程结束而解除DLL映射，在进程结束前还没有解除DLL的映射，进程结束后会解除DLL映射。（如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。）&lt;/p&gt;

&lt;p&gt;注意：当用DLL_PROCESS_ATTACH调用DLL的DllMain函数时，如果返回FALSE，说明没有初始化成功，系统仍会用DLL_PROCESS_DETACH调用DLL的DllMain函数。因此，必须确保清理那些没有成功初始化的东西。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-2&quot;&gt;线程映射&lt;/h4&gt;

&lt;p&gt;DLL_THREAD_ATTACH&lt;/p&gt;

&lt;p&gt;当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，并用值DLL_THREAD_ATTACH调用DLL的DllMain函数。&lt;/p&gt;

&lt;p&gt;新创建的线程负责执行这次的DLL的DllMain函数，只有当所有的DLL都处理完这一通知后，系统才允许进程开始执行它的线程函数。&lt;/p&gt;

&lt;p&gt;注意跟DLL_PROCESS_ATTACH的区别，我们在前面说过，第n(n&amp;gt;=2)次以后地把DLL映像文件映射到进程的地址空间时，是不再用DLL_PROCESS_ATTACH调用DllMain的。而DLL_THREAD_ATTACH不同，进程中的每次建立线程，都会用值DLL_THREAD_ATTACH调用DllMain函数，哪怕是线程中建立线程也一样。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;线程卸载&lt;/h3&gt;
&lt;p&gt;DLL_THREAD_DETACH&lt;/p&gt;

&lt;p&gt;如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread），系统查看当前映射到进程空间中的所有DLL文件映像，并用DLL_THREAD_DETACH来调用DllMain函数，通知所有的DLL去执行线程级的清理工作。
注意：如果线程的结束是因为系统中的一个线程调用了TerminateThread，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;以下是在DLL中的DLLmain的函数入口加载其他DLL示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &quot;df_vision_common.h&quot;
#include &quot;DF_MeasureProIF.h&quot;
#include &amp;lt;Windows.h&amp;gt;

HINSTANCE hDllPattenMatch = NULL;
TDF_PatternMatchFun DF_PatternMatchFun;

HINSTANCE hDllColorDetector = NULL;
TDF_ColorDetectorFun DF_ColorDetectorFun;

BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
BOOL ret = TRUE;

switch (ul_reason_for_call)
{
case DLL_PROCESS_ATTACH://LoadLibrary是调用一次
    hDllPattenMatch = LoadLibrary(&quot;dfmeasurepatternmatch.dll&quot;);
    hDllColorDetector = LoadLibrary(&quot;dfcolordetector.dll&quot;);

    if (hDllColorDetector != NULL &amp;amp;&amp;amp; hDllPattenMatch != NULL)
    {
        DF_ColorDetectorFun = (TDF_ColorDetectorFun)GetProcAddress(hDllColorDetector, &quot;DF_MeasureColorDetectorCalc&quot;);
        DF_PatternMatchFun = (TDF_PatternMatchFun)GetProcAddress(hDllPattenMatch, &quot;DF_MeasurePatternMatch&quot;);
    }
    else
    {
        ret = FALSE;
    }
    break;

case DLL_PROCESS_DETACH://Freelibrary时调用一次

    if(hDllPattenMatch != NULL)
    {
        FreeLibrary(hDllPattenMatch);
        hDllPattenMatch = NULL;
    }

    if (hDllColorDetector != NULL)
    {
        FreeLibrary(hDllColorDetector);
        hDllColorDetector = NULL;
    }
    break;

case DLL_THREAD_ATTACH:
    //printf(&quot;Thread attach. \n&quot;);
    break;

case DLL_THREAD_DETACH:
    //printf(&quot;Thread detach. \n&quot;);
    break;
}

	return (ret);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 15 Oct 2015 16:50:45 +0800</pubDate>
        <link>http://javictory.info/c++/2015/10/15/CallingDLL.html</link>
        <guid isPermaLink="true">http://javictory.info/c++/2015/10/15/CallingDLL.html</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>序言</title>
        <description>&lt;p&gt;开这个博客的原因是因为平常自己也喜欢记一些东西，虽然有自己的文档，但主要是流水账式的记录一些东西，比较乱，不够系统。建立这样一个博客就是为了督促自己，将自己平时的积累进行系统的归纳和分类，同时也是一种经验的分享。&lt;/p&gt;

&lt;p&gt;同时开这个博客的过程也是一种学习，毕竟自己是个小白，什么也不懂，好在喜欢折腾。博观而约取，厚积而薄发。希望这点滴的积累能够帮到我，也能够带给大家一些启发。&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Oct 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/notebook/2015/10/02/pretell.html</link>
        <guid isPermaLink="true">http://javictory.info/notebook/2015/10/02/pretell.html</guid>
        
        
        <category>notebook</category>
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;def print_hi(name)
  puts &amp;quot;Hi, #{name}&amp;quot;
end
print_hi(&amp;#39;Tom&amp;#39;)
#=&amp;gt; prints &amp;#39;Hi, Tom&amp;#39; to STDOUT.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 01 Oct 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/jekyll/2015/10/01/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://javictory.info/jekyll/2015/10/01/welcome-to-jekyll.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
  </channel>
</rss>
