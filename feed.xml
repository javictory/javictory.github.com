<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javicroty&#39;s Blog</title>
    <description>It&#39;s my own blog Recording my growth.&lt;br&gt; &quot;Stay hungry. Stay foolish.--Steve Jobs&quot;
</description>
    <link>http://javictory.info/</link>
    <atom:link href="http://javictory.info/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 12 Mar 2016 00:26:39 +0800</pubDate>
    <lastBuildDate>Sat, 12 Mar 2016 00:26:39 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>Socket编程的select模型</title>
        <description>&lt;p&gt;在掌握了socket相关的一些函数后，套接字编程还是比较简单的，日常工作中碰到很多的问题就是客户端/服务器模型中，如何让服务端在同一时间高效的处理多个客户端的连接，我们的处理办法可能会是在服务端不停的监听客户端的请求，有新的请求到达时，开辟一个新的线程去和该客户端进行后续处理，但是这样针对每一个客户端都需要去开辟一个新的线程，效率必定底下。&lt;/p&gt;

&lt;p&gt;其实，socket编程提供了很多的模型来处理这种情形，我们只要按照模型去实现我们的代码就可以解决这个问题。主要有select模型和重叠I/o模型，以及完成端口模型。这次，我们主要介绍下select模型，该模型又分为普通select模型，wsaasyncselect模型，wsaeventselect模型。我们将通过样例代码的方式逐一介绍。&lt;/p&gt;

&lt;h1 id=&quot;select&quot;&gt;一、select模型&lt;/h1&gt;

&lt;p&gt;使用该模型时，在服务端我们可以开辟两个线程，一个线程用来监听客户端的连接请求，另一个用来处理客户端的请求。&lt;/p&gt;

&lt;p&gt;主要用到的函数为select函数。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;全局变量：

fd_set  g_fdClientSock;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程1处理函数：
	SOCKET listenSock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sockaddr_in sin;
sin.sin_family = AF_INET;
sin.sin_port = htons(7788);
sin.sin_addr.S_un.S_addr = INADDR_ANY;

int nRet = bind( listenSock, (sockaddr*)&amp;amp;sin, (int)(sizeof(sin)));
if ( nRet == SOCKET_ERROR )
{
    DWORD errCode = GetLastError();
    return;
}

listen( listenSock, 5);

int clientNum = 0;

sockaddr_in clientAddr;

int nameLen = sizeof( clientAddr );

while( clientNum &amp;lt; FD_SETSIZE )
{
    SOCKET clientSock = accept( listenSock, (sockaddr*)&amp;amp;clientAddr, &amp;amp;nameLen );
    FD_SET( clientSock, &amp;amp;g_fdClientSock);
    clientNum++;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程2处理函数：
	fd_set fdRead;
    FD_ZERO( &amp;amp;fdRead );
    int nRet = 0;
    char* recvBuffer =(char*)malloc( sizeof(char) * 1024 );&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( recvBuffer == NULL )
{
    return;
}

memset( recvBuffer, 0, sizeof(char) * 1024 );
while ( true )
{
    fdRead = g_fdClientSock;
    nRet = select( 0, &amp;amp;fdRead, NULL, NULL, NULL );
    if ( nRet != SOCKET_ERROR )
    {
        for ( int i = 0; i &amp;lt; g_fdClientSock.fd_count; i++ )
        {
            if ( FD_ISSET(g_fdClientSock.fd_array[i],&amp;amp;fdRead)  )
            {
                memset( recvBuffer, 0, sizeof(char) * 1024 );
                nRet = recv( g_fdClientSock.fd_array[i], recvBuffer, 1024, 0);
                if ( nRet == SOCKET_ERROR )
                {
                    closesocket( g_fdClientSock.fd_array[i] )；
                        FD_CLR( g_fdClientSock.fd_array[i], &amp;amp;g_fdClientSock );
                }
                else
                {
                    //todo:后续处理
                   }
            }
        }
    }
}

if ( recvBuffer != NULL )
{
    free( recvBuffer );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该模型有个最大的缺点就是，它需要一个死循环不停的去遍历所有的客户端套接字集合，询问是否有数据到来，这样，如果连接的客户端很多，势必会影响处理客户端请求的效率，但它的优点就是解决了每一个客户端都去开辟新的线程与其通信的问题。如果有一个模型，可以不用去轮询客户端套接字集合，而是等待系统通知，当有客户端数据到来时，系统自动的通知我们的程序，这就解决了select模型带来的问题了。&lt;/p&gt;

&lt;p&gt;二、WsaAsyncSelect模型
WsaAsyncSelect模型就是这样一个解决了普通select模型问题的socket编程模型。它是在有客户端数据到来时，系统发送消息给我们的程序，我们的程序只要定义好消息的处理方法就可以了，用到的函数只要是WSAAsyncSelect,如：&lt;/p&gt;

&lt;p&gt;首先，我们定义一个Windows消息，告诉系统，当有客户端数据到来时，发送该消息给我们。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define  UM_SOCK_ASYNCRECVMSG  WM_USER + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的处理函数中可以如下监听客户端的连接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKET listenSock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
sockaddr_in sin;
sin.sin_family = AF_INET;
sin.sin_port = htons(7788);
sin.sin_addr.S_un.S_addr = INADDR_ANY;
int nRet = bind( listenSock, (sockaddr*)&amp;amp;sin, (int)(sizeof(sin)));
if ( nRet == SOCKET_ERROR )
{
    DWORD errCode = GetLastError();
    return;
}

listen( listenSock, 5);

int clientNum = 0;
sockaddr_in clientAddr;
int nameLen = sizeof( clientAddr );

while( clientNum &amp;lt; FD_SETSIZE )
{
    SOCKET clientSock = accept( listenSock, (sockaddr*)&amp;amp;clientAddr, &amp;amp;nameLen );
    //hWnd为接收系统发送的消息的窗口句柄
     WSAAsyncSelect( clientSock, hWnd, UM_SOCK_ASYNCRECVMSG, FD_READ | FD_CLOSE );
    clientNum++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们需要在我们的窗口添加对UM_SOCK_ASYNCRECVMSG消息的处理函数，在该函数中真正接收客户端发送过来的数据，在这个消息处理函数中的wparam参数表示的是客户端套接字，lparam参数表示的是发生的网络事件如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKET clientSock = (SOCKET)wParam;
if ( WSAGETSELECTERROR( lParam ) )
{
  closesocket( clientSock );
  return;
}

switch ( WSAGETSELECTEVENT( lParam ) )
{
   case FD_READ:
   {
       char recvBuffer[1024] = {&#39;\0&#39;};
       int nRet = recv( clientSock, recvBuffer, 1024, 0 );
       if ( nRet &amp;gt; 0 )
       {
            szRecvMsg.AppendFormat(_T(&quot;Client %d Say:%s\r\n&quot;), clientSock, recvBuffer );
       }
       else
       {
            //client disconnect
            szRecvMsg.AppendFormat(_T(&quot;Client %d Disconnect!\r\n&quot;), clientSock );
       }
    }                              

    break;

  case FD_CLOSE:
  {
       closesocket( clientSock );
       szRecvMsg.AppendFormat(_T(&quot;Client %d Disconnect!\r\n&quot;), clientSock );
  }

  break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到WsaAsyncSelect模型是非常简单的模型，它解决了普通select模型的问题，但是它最大的缺点就是它只能用在windows程序上，因为它需要一个接收系统消息的窗口句柄，那么有没有一个模型既可以解决select模型的问题，又不限定只能是windows程序才能用呢？下面我们来看看WsaEventSelect模型。&lt;/p&gt;

&lt;p&gt;三、WsaEventSelect模型&lt;/p&gt;

&lt;p&gt;WsaEventSelect模型是一个不用主动去轮询所有客户端套接字是否有数据到来的模型，它也是在客户端有数据到来时，系统发送通知给我们的程序，但是，它不是发送消息，而是通过事件的方式来通知我们的程序，这就解决了WsaAsyncSelect模型只能用在windows程序的问题。&lt;/p&gt;

&lt;p&gt;该模型的实现，我们也可以开辟两个线程来进行处理，一个用来接收客户端的连接请求，一个用来与客户端进行通信，用到的主要函数有WSAEventSelect，WSAWaitForMultipleEvents，WSAEnumNetworkEvents实现方式如下：&lt;/p&gt;

&lt;p&gt;首先定义三个全局数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKET      g_SockArray[MAX_NUM_SOCKET];//存放客户端套接字

WSAEVENT    g_EventArray[MAX_NUM_SOCKET];//存放该客户端有数据到来时，触发的事件

UINT32      g_totalEvent = 0;//记录客户端的连接数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程1处理函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOCKET listenSock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
sockaddr_in sin;
sin.sin_family = AF_INET;
sin.sin_port = htons(7788);
sin.sin_addr.S_un.S_addr = INADDR_ANY;
int nRet = bind( listenSock, (sockaddr*)&amp;amp;sin, (int)(sizeof(sin)));
if ( nRet == SOCKET_ERROR )
{
    DWORD errCode = GetLastError();
    return；
}

listen( listenSock, 5);

sockaddr_in clientAddr;
int nameLen = sizeof( clientAddr );
while( g_totalEvent &amp;lt; MAX_NUM_SOCKET )
{
    SOCKET clientSock = accept( listenSock, (sockaddr*)&amp;amp;clientAddr, &amp;amp;nameLen );
    if ( clientSock == INVALID_SOCKET )
    {
        continue;
    }
    g_SockArray[g_totalEvent] = clientSock;

    if( (g_EventArray[g_totalEvent] = WSACreateEvent()) == WSA_INVALID_EVENT )
    {
        continue;
    }

    WSAEventSelect( clientSock, g_EventArray[g_totalEvent],FD_READ | FD_CLOSE );
    g_totalEvent++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程2的处理函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int nIndex = 0;
char* recvBuffer =(char*)malloc( sizeof(char) * 1024 );

if ( recvBuffer == NULL )
{
	return；
}

memset( recvBuffer, 0, sizeof(char) * 1024 );

while( true )
{
    nIndex = WSAWaitForMultipleEvents( g_totalEvent, g_EventArray, FALSE, WSA_INFINITE,FALSE );
    if ( nIndex == WSA_WAIT_FAILED )
    {
        continue;
    }
    else
    { 
        WSAResetEvent( g_EventArray[ nIndex - WSA_WAIT_EVENT_0]);
        SOCKET clientSock = g_SockArray[ nIndex - WSA_WAIT_EVENT_0 ];
        WSANETWORKEVENTS wsaNetWorkEvent;

        int nRet = WSAEnumNetworkEvents( clientSock, g_EventArray[nIndex - WSA_WAIT_EVENT_0], &amp;amp;wsaNetWorkEvent );
        if ( SOCKET_ERROR == nRet )
        {
            continue;
        }
        else if ( wsaNetWorkEvent.lNetworkEvents &amp;amp; FD_READ )
        {
            if ( wsaNetWorkEvent.iErrorCode[FD_READ_BIT] != 0 )
            {
                //occur error
                closesocket( clientSock );
            }
            else 
            {
                memset( recvBuffer, 0, sizeof(char) * 1024 );
                nRet = recv( clientSock, recvBuffer, 1024, 0);
                if ( nRet == SOCKET_ERROR )
                {
                    closesocket( clientSock );
                }
                else
                {
                    //todo:对接收到的客户端数据进行处理
                    }
             }
         }
         else if( wsaNetWorkEvent.lNetworkEvents &amp;amp; FD_CLOSE )
         {
            if ( wsaNetWorkEvent.iErrorCode[FD_CLOSE_BIT] != 0 )
            {
                //occur error
                closesocket( clientSock );
            }
            else
            {
                closesocket( clientSock );
            }  
         }
    }
}

if ( recvBuffer != NULL )
{
    free( recvBuffer );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该模型通过一个死循环里面调用WSAWaitForMultipleEvents函数来等待客户端套接字对应的Event的到来，一旦事件通知到达，就通过该套接字去接收数据。虽然WsaEventSelect模型的实现较前两种方法复杂，但它在效率和兼容性方面是最好的。&lt;/p&gt;

&lt;p&gt;以上三种模型虽然在效率方面有了不少的提升，但它们都存在一个问题，就是都预设了只能接收64个客户端连接，虽然我们在实现时可以不受这个限制，但是那样，它们所带来的效率提升又将打折扣。&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Jan 2016 19:30:45 +0800</pubDate>
        <link>http://javictory.info/sockets/2016/01/13/windows-socket-select-module.html</link>
        <guid isPermaLink="true">http://javictory.info/sockets/2016/01/13/windows-socket-select-module.html</guid>
        
        
        <category>sockets</category>
        
      </item>
    
      <item>
        <title>常见字符集区别：</title>
        <description>&lt;p&gt;1、LPTSTR、LPCSTR、LPCTSTR、LPSTR的意义：&lt;/p&gt;

&lt;p&gt;(1) LPSTR：32bit指针 指向一个字符串，每个字符占1字节；&lt;/p&gt;

&lt;p&gt;(2) LPCSTR：32-bit指针 指向一个常字符串，每个字符占1字节；&lt;/p&gt;

&lt;p&gt;(3) LPCTSTR：32-bit指针 指向一个常字符串,每字符可能占1字节或2字节，取决于Unicode是否定义，T表示在Win32环境中， 有一个_T宏；&lt;/p&gt;

&lt;p&gt;(4) LPTSTR：32-bit指针 每字符可能占1字节或2字节，取决于Unicode是否定义。&lt;/p&gt;

&lt;p&gt;2、Multi-Byte Character Set：&lt;/p&gt;

&lt;p&gt;MBCS，它是多字节字符集，它是不定长表示世界文字的编码。&lt;/p&gt;

&lt;p&gt;MBCS表示英文字母时就和ASCII一样（这也是我们容易把MBCS和ASCII搞混的原因），但表示其他文字时就需要用多字节。&lt;/p&gt;

&lt;p&gt;WINDOWS下面的程序设计可以支持MBCS和UNICODE两种编码的字符串，具体用那种就看你定义了MBCS宏还是UNICODE宏。&lt;/p&gt;

&lt;p&gt;MBCS宏对应的字符串指针是char* 也就是LPSTR；&lt;/p&gt;

&lt;p&gt;UNICODE对应的指针是unsigned  short* 也就是LPWSTR；&lt;/p&gt;

&lt;p&gt;为了写程序方便，微软定义了类型LPTSTR，在MBCS下他就是char* ,   在UNICODE下它是unsigned   char* ,这样你就可以重定义一个宏进行不同字符集的转换了。&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Dec 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/windows/2015/12/08/win-common-charset.html</link>
        <guid isPermaLink="true">http://javictory.info/windows/2015/12/08/win-common-charset.html</guid>
        
        
        <category>Windows</category>
        
      </item>
    
      <item>
        <title>C++ 基础</title>
        <description>&lt;p&gt;基本语法&lt;/p&gt;

&lt;p&gt;1、全局变量个局部变量&lt;/p&gt;

&lt;p&gt;如下面的这一串代码&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;#include &amp;lt;iostream&amp;gt;

  #include &amp;lt;stdlib.h&amp;gt;

  using namespace std;
  
  int vac=3;

  int main(){

  	int vac=10;
  	::vac++;
  	cout&amp;lt;&amp;lt;::vac&amp;lt;&amp;lt;endl;
  	cout&amp;lt;&amp;lt;vac&amp;lt;&amp;lt;endl;
  	system(&amp;quot;pause&amp;quot;);
  	return 0 ;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;其中，有几个地方需要做一下说明：&lt;/p&gt;

&lt;p&gt;(1)在调试的时候，想要让弹出console的时候停止 需要添加system(“pause”)，方便进行观看。&lt;/p&gt;

&lt;p&gt;(2)::是域操作符，::前面可以是 类名，命名空间名 来限定 ::后面的内容从哪里读取，在这里如果 ::前面没有域名 那么就是全局；：：vac代表的即是全局变量。&lt;/p&gt;

&lt;p&gt;(3)而在main函数里面定义的 vac函数则是局部变量。&lt;/p&gt;

&lt;p&gt;2、变量初始化&lt;/p&gt;

&lt;p&gt;形式：&lt;变量名&gt;(表达式)&lt;/变量名&gt;&lt;/p&gt;

&lt;p&gt;例如：int a(4); //与C语言中的int a=4;是等价的。&lt;/p&gt;

&lt;p&gt;3、C++符号常量 const&lt;/p&gt;

&lt;p&gt;C++有符号常量而C中是没有的&lt;/p&gt;

&lt;p&gt;C++的格式： const &lt;类型&gt;&lt;符号常量&gt;=值;&lt;/符号常量&gt;&lt;/类型&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如 ：const float PI=3.1415926; // C为 #define PI 3.1415926;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1)与C相比，用const定义的符号常量具有数据类型，而且作用域可以是局部的。&lt;/p&gt;

&lt;p&gt;(2)const 可以是参数指针不被改变&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 例如： int sum(const int *a);    (3)调用时，不想改变引用变量a的值

 例如： void f(const int &amp;amp;a,int b){...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、自增判断&lt;/p&gt;

&lt;p&gt;#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;

&lt;p&gt;using namespace std;&lt;/p&gt;

&lt;p&gt;#define product(x) (x*x);&lt;/p&gt;

&lt;p&gt;int main(){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i=3,j,k;

j=product(i++);//此处的表达式为(i++)*(i++)，运行结束后，i==5；

k=product(++i);//此处的表达式为(++i)*(++i),在得到运算结果之前，i==7

cout&amp;lt;&amp;lt;&quot;j=&quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&quot;k=&quot;&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl;

system(&quot;pause&quot;);

return 0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5、在VC++ 编写dll时应当注意在.c文件和在.CPP文件下的区别。      &lt;br /&gt;
   在.cpp文件下无论是动态链接库的创建还是调用，都要声明一下extern “C” ；&lt;/p&gt;

&lt;p&gt;6、在C中是没有string类型的，因此都是用字符数组进行
   字符数组也没有办法直接进行字符串的赋值
   只有在初始化的时候可以直接进行赋值&lt;/p&gt;

&lt;p&gt;7、main函数中参数的意义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main(int argc, char* argv[])
{
	return 0;
}    两个参数是给读入命令行参数的：
&lt;/code&gt;&lt;/pre&gt;

   	argc表示参数个数，Count;

   	argv[]存放参数，Value;
</description>
        <pubDate>Tue, 01 Dec 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/c++/2015/12/01/C++-Basic.html</link>
        <guid isPermaLink="true">http://javictory.info/c++/2015/12/01/C++-Basic.html</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>VC++中动静态链接库的调用</title>
        <description>&lt;p&gt;1、动态链接库在调用时要注意:&lt;/p&gt;

&lt;p&gt;格式为hdll=LoadLibrary（“DLL地址”）；&lt;/p&gt;

&lt;p&gt;这里字符串类型是LPSTR，当VS中工程属性设置是unicode字符集的时候会提示错误，
   因此要在配置-Property-General-&amp;gt;Character Set 里面把默认字符集“unicode”改成支持多字符扩展或者notset即可。&lt;/p&gt;

&lt;p&gt;2、动态链接库DLL的调用分为动态调用和静态调用&lt;/p&gt;

&lt;p&gt;(1)DLL的静态调用&lt;/p&gt;

&lt;p&gt;在程序中要静态调用一个dll文件，一般会有下面这么一句 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pragma comment(lib, &quot;dll2.lib&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然这不是必须的，也可以通过工程 设置 链接 添加这个lib。&lt;/p&gt;

&lt;p&gt;意思是要把dll2.lib这个文件的信息编译到exe这个程序当中的，所以你必须把你的dll2.lib和dll2.dll都得放入exe所在的文件夹；&lt;/p&gt;

&lt;p&gt;dll2.lib是用于编译的时候用的，  dll2.dll是当exe文件执行的时候用的；&lt;/p&gt;

&lt;p&gt;当编译好了以后 这个dll2.lib文件就没有用了 ，因为它的信息已经编译到exe中了；&lt;/p&gt;

&lt;p&gt;所以当你发布的时候 就可以把这个dll2.lib删除了，只留下dll2.dll就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如：

#include &amp;lt;iostream&amp;gt;
#pragma comment(lib,&quot;Mydll2.lib&quot;)
extern &quot;C&quot; __declspec(dllimport) int add(int x,int y);
int main(int argc, char* argv[])
{
	int result = add(2,3);
	printf(&quot;%d&quot;,result);
	getchar();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2)DLL的动态调用：&lt;/p&gt;

&lt;p&gt;只需要dll就可以了，和lib一点关系都没有。&lt;/p&gt;

&lt;p&gt;可以用Extern，也可以用.def文件导出函数接口，供外部工程调用。&lt;/p&gt;

&lt;p&gt;动态链接库在调用时要注意： &lt;/p&gt;

&lt;p&gt;格式为hdll=LoadLibrary（“DLL地址”）；&lt;/p&gt;

&lt;p&gt;这里字符串类型是LPSTR，不是unicode字符，
   因此要配置 -Property-General-&amp;gt;Character Set 里面把默认字符集“unicode”改成支持多字符扩展或者notset即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如：

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;windows.h&amp;gt; 
typedef int(*lpAddFun)(int , int);

int main(int argc, char* argv[])
{
	HINSTANCE hDll;
	lpAddFun addFun;
	hDll = LoadLibrary(&quot;Mydll2.dll&quot;);
	if (hDll != NULL)
	{
		addFun = (lpAddFun)GetProcAddress(hDll, &quot;add&quot;);
		if (addFun != NULL)
		{
			int result = addFun(2, 3);
			printf(&quot;%d&quot;, result);
	   	 	getchar();
		}
		FreeLibrary(hDll);
	}
   	 	getchar();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、DLL工程和实际引用工程联调&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Nov 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/c++/2015/11/12/C++-DLL.html</link>
        <guid isPermaLink="true">http://javictory.info/c++/2015/11/12/C++-DLL.html</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>Ubuntu 常用快捷键</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;一、桌面&lt;/h1&gt;

&lt;p&gt;ALT + F1: 聚焦到桌面左侧任务导航栏，可按上下键导航。&lt;/p&gt;

&lt;p&gt;ALT + F2: 运行命令&lt;/p&gt;

&lt;p&gt;ALT + F4: 关闭窗口&lt;/p&gt;

&lt;p&gt;ALT + TAB: 切换程序窗口&lt;/p&gt;

&lt;p&gt;ALT + 空格: 打开窗口菜单&lt;/p&gt;

&lt;p&gt;PRINT: 桌面截图&lt;/p&gt;

&lt;p&gt;SUPER: 打开Dash面板，可搜索或浏览项目，默认有个搜索框，按“下”方向键进入浏览区域（SUPER键指Win键或苹果电脑的Command键）&lt;/p&gt;

&lt;p&gt;在Dash面板中按CTRL + TAB: 切换到下一个子面板（可搜索不同类型项目，如程序、文件、音乐）&lt;/p&gt;

&lt;p&gt;SUPER + A: 搜索或浏览程序（Application）&lt;/p&gt;

&lt;p&gt;SUPER + F: 搜索或浏览文件（File）&lt;/p&gt;

&lt;p&gt;SUPER + M: 搜索或浏览音乐文件（Music）&lt;/p&gt;

&lt;h1 id=&quot;terminal&quot;&gt;二、Terminal终端&lt;/h1&gt;

&lt;p&gt;CTRL + ALT + T: 打开终端&lt;/p&gt;

&lt;p&gt;TAB: 自动补全命令或文件名&lt;/p&gt;

&lt;p&gt;CTRL + SHIFT + V: 粘贴（Linux中不需要复制的动作，文本被选择就自动被复制）&lt;/p&gt;

&lt;p&gt;CTRL + SHIFT + T: 新建标签页&lt;/p&gt;

&lt;p&gt;CTRL + D: 关闭标签页&lt;/p&gt;

&lt;p&gt;CTRL + L: 清除屏幕&lt;/p&gt;

&lt;p&gt;CTRL + R + 文本: 在输入历史中搜索&lt;/p&gt;

&lt;p&gt;CTRL + A: 移动到行首&lt;/p&gt;

&lt;p&gt;CTRL + E: 移动到行末&lt;/p&gt;

&lt;p&gt;CTRL + C: 终止当前任务&lt;/p&gt;

&lt;p&gt;CTRL + Z: 把当前任务放到后台运行（相当于运行命令时后面加&amp;amp;）&lt;/p&gt;

&lt;p&gt;~: 表示用户目录路径&lt;/p&gt;

&lt;h1 id=&quot;nautilus&quot;&gt;三、Nautilus文件管理器&lt;/h1&gt;

&lt;p&gt;启动Nautilus的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;SUPER + 1，这个方法仅适用于Nautilus在左边快速启动的位置没有改变的情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SUPER + A，然后输入nautilus，然后回车&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;F2: 重命名&lt;/p&gt;

&lt;p&gt;CTRL + 1: 图标视图&lt;/p&gt;

&lt;p&gt;CTRL + 2: 列表视图&lt;/p&gt;

&lt;p&gt;CTRL + T: 新建标签页&lt;/p&gt;

&lt;p&gt;CTRL + W: 关闭标签页&lt;/p&gt;

&lt;p&gt;CTRL + D: 收藏到书签&lt;/p&gt;

&lt;p&gt;CTRL + Q: 退出&lt;/p&gt;

&lt;p&gt;Nautilus还有很多和Firefox一致的快捷键。&lt;/p&gt;

&lt;h1 id=&quot;firefox&quot;&gt;四、Firefox浏览器&lt;/h1&gt;
&lt;p&gt;进入Firefox的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;SUPER + A，然后按firefox，回车。这个是在Dash面板中搜索应用程序运行。事实上，只要按fir就能定位到Firefox程序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ALT，然后按firefox，回车。这个相当于在命令行运行一条命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在终端中按firefox&amp;amp;，回车。这个适用于以终端作为主要操作窗口的用户，使用TAB键还可以自动补全命令（只需输入前几个字母再按TAB键）。&amp;amp;在shell中是后台运行的意思，这样终端就不会被Firefox独占。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CTRL + T: 新建标签页&lt;/p&gt;

&lt;p&gt;CTRL + W: 关闭标签页&lt;/p&gt;

&lt;p&gt;CTRL + SHIFT + T: 重新打开最近关闭的一个标签页&lt;/p&gt;

&lt;p&gt;CTRL + TAB: 切换到下一个标签页&lt;/p&gt;

&lt;p&gt;CTRL + SHIFT + TAB: 切换到上一个标签页&lt;/p&gt;

&lt;p&gt;ALT + [1-8]: 跳到制定标签页&lt;/p&gt;

&lt;p&gt;ALT + 9: 跳到最后一个标签页&lt;/p&gt;

&lt;p&gt;CTRL + L: 跳到地址栏&lt;/p&gt;

&lt;p&gt;ESC: 停止加载当前页面&lt;/p&gt;

&lt;p&gt;CTRL + K: 跳到搜索引擎输入框&lt;/p&gt;

&lt;p&gt;CTRL + F: 在当前页面中搜索&lt;/p&gt;

&lt;p&gt;/: 快速查找。在Linux中很多程序（如VI、Man、Less）都使用/作为搜索的快捷键，并且可使用正则表达式查找。但在Firefox中没有正则表达式搜索的功能。&lt;/p&gt;

&lt;p&gt;CTRL + D: 收藏到书签&lt;/p&gt;

&lt;p&gt;ALT + 左方向键: 后退&lt;/p&gt;

&lt;p&gt;ALT + v: 前进&lt;/p&gt;

&lt;p&gt;CTRL + Q: 退出&lt;/p&gt;

&lt;h1 id=&quot;orca&quot;&gt;五、Orca读屏软件&lt;/h1&gt;

&lt;p&gt;启动Orca: SUPER + A，然后输入orca，然后回车&lt;/p&gt;

&lt;p&gt;ORCA + 空格: 显示首选项对话框（ORCA键是指Insert插入键或CAPS LOCK大小写转换键，取决于设置）&lt;/p&gt;

&lt;p&gt;ORCA + t: 读当前时间&lt;/p&gt;

&lt;p&gt;ORCA + tt: 读当前日期&lt;/p&gt;

&lt;p&gt;ORCA + s: 切换合成语音开关&lt;/p&gt;

&lt;p&gt;ORCA + /: 朗读标题&lt;/p&gt;

&lt;p&gt;ORCA + //: 朗读状态栏&lt;/p&gt;

&lt;p&gt;ORCA + 分号: 朗读整个文件&lt;/p&gt;

&lt;p&gt;ORCA + Q: 退出Orca&lt;/p&gt;

&lt;h1 id=&quot;rhythmbox&quot;&gt;六、Rhythmbox音频播放器&lt;/h1&gt;

&lt;p&gt;CTRL + 空格: 播放/暂停&lt;/p&gt;

&lt;p&gt;ALT + 右方向键: 下一首&lt;/p&gt;

&lt;p&gt;ALT + 左方向键: 上一首&lt;/p&gt;

&lt;p&gt;CTRL + 上方向键: 增大音量&lt;/p&gt;

&lt;p&gt;CTRL + 下方向键: 减少音量&lt;/p&gt;

&lt;p&gt;CTRL + U: 随机播放&lt;/p&gt;

&lt;p&gt;CTRL + R: 重复播放&lt;/p&gt;

&lt;p&gt;CTRL + Q: 退出&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;七、如何打开一个程序&lt;/h1&gt;

&lt;p&gt;以“系统配置”为例，先按SUPER + A，SUPER即Win键，然后切换到中文输入法，输入“系统配置”，按回车即打开程序。&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://javictory.info/ubuntu/2015/11/09/ubuntu-common-shortcutkey.html</link>
        <guid isPermaLink="true">http://javictory.info/ubuntu/2015/11/09/ubuntu-common-shortcutkey.html</guid>
        
        
        <category>Ubuntu</category>
        
      </item>
    
      <item>
        <title>VC++ 6.0 编译器相关设置</title>
        <description>&lt;p&gt;1、结构体中所有成员的对齐参数N的最大值称为结构体的对齐参数。 &lt;/p&gt;

&lt;p&gt;VC++6.0中n 默认是8个字节，可以修改这个设定的对齐参数；&lt;/p&gt;

&lt;p&gt;(1)方法一：&lt;/p&gt;

&lt;p&gt;在菜单“工程”的“设置”中的“C/C++”选项卡的“分类”中， “Code Generation ”的“Struct member alignment” 中设置：&lt;/p&gt;

&lt;p&gt;1byte、2byte、4byte、8byte、16byte等几种，默认为8byte。&lt;/p&gt;

&lt;p&gt;(2)方法二：&lt;/p&gt;

&lt;p&gt;可以程序控制，采用指令：
		#pragma   pack(xx)控制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 例如：
	#pragma   pack(1),1字节对齐，
	#pragma   pack(4)，4字节对齐，
	#pragma   pack(16)，16字节对齐   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们将分不同的情况来详细讨论结构体成员的分布情况，顺便提醒一下， 常见类型的长度：&lt;/p&gt;

&lt;p&gt;Int 4byte, Short 2byte, Char 1byte, Double 8byte, Long 4byte ；  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;让我们先看下例： 

Struct  A 
{
	char   c; //1byte  
	double d; //8byte  
	short s;  //2byte  
	int   i;  //4byte  
};  

int main(int argc, char* argv[]) 
{ 
	A  strua;
	printf(&quot;%len:d\n&quot;,sizeof(A));     
	printf(&quot;%d,%d,%d,%d&quot;,&amp;amp;strua.c,&amp;amp;strua.d,&amp;amp;strua.s,&amp;amp;strua.i);  
	return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;n设置为8byte时 结果：len:24, &lt;/p&gt;

&lt;p&gt;1245032,1245040,1245048,1245052 内存中成员分布如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://javictory.info/img/img_append/C++VS2008-1.png&quot; alt=&quot;Preview&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、用 devenv.exe /resetuserdata 恢复Visual Studio 初始状态&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Nov 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/c++/2015/11/08/C++-VS2008.html</link>
        <guid isPermaLink="true">http://javictory.info/c++/2015/11/08/C++-VS2008.html</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>DLL的入口函数_DLLMain</title>
        <description>&lt;p&gt;跟exe有个main或者WinMain入口函数一样，DLL也有一个入口函数，就是DllMain。对于动态链接库，DllMain是一个可选的入口函数。&lt;/p&gt;

&lt;p&gt;系统是在什么时候调用DllMain函数的呢？静态链接时，或动态链接时调用LoadLibrary和FreeLibrary都会调用DllMain函数。DllMain的第二个参数fdwReason指明了系统调用Dll的原因，它可能是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DLL_PROCESS_ATTACH

DLL_PROCESS_DETACH

DLL_THREAD_ATTACH

DLL_THREAD_DETACH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下从这四种情况来分析系统何时调用了DllMain。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;进程映射&lt;/h4&gt;

&lt;p&gt;DLL_PROCESS_ATTACH&lt;/p&gt;

&lt;p&gt;大家都知道，一个程序要调用Dll里的函数，首先要先把DLL文件映射到进程的地址空间。要把一个DLL文件映射到进程的地址空间，有两种方法：静态链接和动态链接的LoadLibrary或者LoadLibraryEx。&lt;/p&gt;

&lt;p&gt;当一个DLL文件被映射到进程的地址空间时，系统调用该DLL的DllMain函数，传递的fdwReason参数为DLL_PROCESS_ATTACH，这种调用只会发生在第一次映射时。如果同一个进程后来为已经映射进来的DLL再次调用LoadLibrary或者LoadLibraryEx，操作系统只会增加DLL的使用次数，它不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。不同进程用LoadLibrary同一个DLL时，每个进程的第一次映射都会用DLL_PROCESS_ATTACH调用DLL的DllMain函数。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-1&quot;&gt;进程卸载&lt;/h4&gt;

&lt;p&gt;DLL_PROCESS_DETACH&lt;/p&gt;

&lt;p&gt;当DLL被从进程的地址空间解除映射时，系统调用了它的DllMain，传递的fdwReason值是DLL_PROCESS_DETACH。当DLL处理该值时，它应该执行进程相关的清理工作。
那么什么时候DLL被从进程的地址空间解除映射呢？两种情况：&lt;/p&gt;

&lt;p&gt;◆FreeLibrary解除DLL映射（有几个LoadLibrary，就要有几个FreeLibrary）&lt;/p&gt;

&lt;p&gt;◆进程结束而解除DLL映射，在进程结束前还没有解除DLL的映射，进程结束后会解除DLL映射。（如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。）&lt;/p&gt;

&lt;p&gt;注意：当用DLL_PROCESS_ATTACH调用DLL的DllMain函数时，如果返回FALSE，说明没有初始化成功，系统仍会用DLL_PROCESS_DETACH调用DLL的DllMain函数。因此，必须确保清理那些没有成功初始化的东西。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-2&quot;&gt;线程映射&lt;/h4&gt;

&lt;p&gt;DLL_THREAD_ATTACH&lt;/p&gt;

&lt;p&gt;当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，并用值DLL_THREAD_ATTACH调用DLL的DllMain函数。&lt;/p&gt;

&lt;p&gt;新创建的线程负责执行这次的DLL的DllMain函数，只有当所有的DLL都处理完这一通知后，系统才允许进程开始执行它的线程函数。&lt;/p&gt;

&lt;p&gt;注意跟DLL_PROCESS_ATTACH的区别，我们在前面说过，第n(n&amp;gt;=2)次以后地把DLL映像文件映射到进程的地址空间时，是不再用DLL_PROCESS_ATTACH调用DllMain的。而DLL_THREAD_ATTACH不同，进程中的每次建立线程，都会用值DLL_THREAD_ATTACH调用DllMain函数，哪怕是线程中建立线程也一样。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;线程卸载&lt;/h3&gt;
&lt;p&gt;DLL_THREAD_DETACH&lt;/p&gt;

&lt;p&gt;如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread），系统查看当前映射到进程空间中的所有DLL文件映像，并用DLL_THREAD_DETACH来调用DllMain函数，通知所有的DLL去执行线程级的清理工作。
注意：如果线程的结束是因为系统中的一个线程调用了TerminateThread，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;以下是在DLL中的DLLmain的函数入口加载其他DLL示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &quot;df_vision_common.h&quot;
#include &quot;DF_MeasureProIF.h&quot;
#include &amp;lt;Windows.h&amp;gt;

HINSTANCE hDllPattenMatch = NULL;
TDF_PatternMatchFun DF_PatternMatchFun;

HINSTANCE hDllColorDetector = NULL;
TDF_ColorDetectorFun DF_ColorDetectorFun;

BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
BOOL ret = TRUE;

switch (ul_reason_for_call)
{
case DLL_PROCESS_ATTACH://LoadLibrary是调用一次
    hDllPattenMatch = LoadLibrary(&quot;dfmeasurepatternmatch.dll&quot;);
    hDllColorDetector = LoadLibrary(&quot;dfcolordetector.dll&quot;);

    if (hDllColorDetector != NULL &amp;amp;&amp;amp; hDllPattenMatch != NULL)
    {
        DF_ColorDetectorFun = (TDF_ColorDetectorFun)GetProcAddress(hDllColorDetector, &quot;DF_MeasureColorDetectorCalc&quot;);
        DF_PatternMatchFun = (TDF_PatternMatchFun)GetProcAddress(hDllPattenMatch, &quot;DF_MeasurePatternMatch&quot;);
    }
    else
    {
        ret = FALSE;
    }
    break;

case DLL_PROCESS_DETACH://Freelibrary时调用一次

    if(hDllPattenMatch != NULL)
    {
        FreeLibrary(hDllPattenMatch);
        hDllPattenMatch = NULL;
    }

    if (hDllColorDetector != NULL)
    {
        FreeLibrary(hDllColorDetector);
        hDllColorDetector = NULL;
    }
    break;

case DLL_THREAD_ATTACH:
    //printf(&quot;Thread attach. \n&quot;);
    break;

case DLL_THREAD_DETACH:
    //printf(&quot;Thread detach. \n&quot;);
    break;
}

	return (ret);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 15 Oct 2015 16:50:45 +0800</pubDate>
        <link>http://javictory.info/c++/2015/10/15/CallingDLL.html</link>
        <guid isPermaLink="true">http://javictory.info/c++/2015/10/15/CallingDLL.html</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>序言</title>
        <description>&lt;p&gt;开这个博客的原因是因为平常自己也喜欢记一些东西，虽然有自己的文档，但主要是流水账式的记录一些东西，比较乱，不够系统。建立这样一个博客就是为了督促自己，将自己平时的积累进行系统的归纳和分类，同时也是一种经验的分享。&lt;/p&gt;

&lt;p&gt;同时开这个博客的过程也是一种学习，毕竟自己是个小白，什么也不懂，好在喜欢折腾。博观而约取，厚积而薄发。希望这点滴的积累能够帮到我，也能够带给大家一些启发。&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Oct 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/notebook/2015/10/02/pretell.html</link>
        <guid isPermaLink="true">http://javictory.info/notebook/2015/10/02/pretell.html</guid>
        
        
        <category>notebook</category>
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;def print_hi(name)
  puts &amp;quot;Hi, #{name}&amp;quot;
end
print_hi(&amp;#39;Tom&amp;#39;)
#=&amp;gt; prints &amp;#39;Hi, Tom&amp;#39; to STDOUT.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 01 Oct 2015 15:30:45 +0800</pubDate>
        <link>http://javictory.info/jekyll/2015/10/01/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://javictory.info/jekyll/2015/10/01/welcome-to-jekyll.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
  </channel>
</rss>
